* Tutorial
#+begin_src emacs-lisp
  ;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

  ;; Place your private configuration here! Remember, you do not need to run 'doom
  ;; sync' after modifying this file!


  ;; Some functionality uses this to identify you, e.g. GPG configuration, email
  ;; clients, file templates and snippets. It is optional.
  ;; (setq user-full-name "John Doe"
  ;;       user-mail-address "john@doe.com")
  ;; Doom exposes five (optional) variables for controlling fonts in Doom:
  ;;
  ;; - `doom-font' -- the primary font to use
  ;; - `doom-variable-pitch-font' -- a non-monospace font (where applicable)
  ;; - `doom-big-font' -- used for `doom-big-font-mode'; use this for
  ;;   presentations or streaming.
  ;; - `doom-unicode-font' -- for unicode glyphs
  ;; - `doom-serif-font' -- for the `fixed-pitch-serif' face
  ;;
  ;; See 'C-h v doom-font' for documentation and more examples of what they
  ;; accept. For example:
  ;;
  ;;(setq doom-font (font-spec :family "Fira Code" :size 12 :weight 'semi-light)
  ;;      doom-variable-pitch-font (font-spec :family "Fira Sans" :size 13))
  ;;
  ;; If you or Emacs can't find your font, use 'M-x describe-font' to look them
  ;; up, `M-x eval-region' to execute elisp code, and 'M-x doom/reload-font' to
  ;; refresh your font settings. If Emacs still can't find your font, it likely
  ;; wasn't installed correctly. Font issues are rarely Doom issues!

  ;; There are two ways to load a theme. Both assume the theme is installed and
  ;; available. You can either set `doom-theme' or manually load a theme with the
  ;; `load-theme' function. This is the default:
  ;;(setq doom-theme 'doom-one)

  ;; This determines the style of line numbers in effect. If set to `nil', line
  ;; numbers are disabled. For relative line numbers, set this to `relative'.
  (setq display-line-numbers-type t)

  ;; If you use `org' and don't want your org files in the default location below,
  ;; change `org-directory'. It must be set before org loads!
  (setq org-directory "~/org/")


  ;; Whenever you reconfigure a package, make sure to wrap your config in an
  ;; `after!' block, otherwise Doom's defaults may override your settings. E.g.
  ;;
  ;;   (after! PACKAGE
  ;;     (setq x y))
  ;;
  ;; The exceptions to this rule:
  ;;
  ;;   - Setting file/directory variables (like `org-directory')
  ;;   - Setting variables which explicitly tell you to set them before their
  ;;     package is loaded (see 'C-h v VARIABLE' to look up their documentation).
  ;;   - Setting doom variables (which start with 'doom-' or '+').
  ;;
  ;; Here are some additional functions/macros that will help you configure Doom.
  ;;
  ;; - `load!' for loading external *.el files relative to this one
  ;; - `use-package!' for configuring packages
  ;; - `after!' for running code after a package has loaded
  ;; - `add-load-path!' for adding directories to the `load-path', relative to
  ;;   this file. Emacs searches the `load-path' when you load packages with
  ;;   `require' or `use-package'.
  ;; - `map!' for binding new keys
  ;;
  ;; To get information about any of these functions/macros, move the cursor over
  ;; the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
  ;; This will open documentation for it, including demos of how they are used.
  ;; Alternatively, use `C-h o' to look up a symbol (functions, variables, faces,
  ;; etc).
  ;;
  ;; You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
  ;; they are implemented. #+end_src
#+end_src

* look and feel
** No modeline
*** dired
#+begin_src emacs-lisp
;; (defun hide-modeline-in-dired-mode ()
;;   "Hide the modeline in `dired-mode'."
;;   (setq mode-line-format nil))

;; (add-hook 'dired-mode-hook 'hide-modeline-in-dired-mode)
#+end_src
*** Vterm
#+begin_src emacs-lisp
;; (defun hide-modeline-in-dired-mode ()
;;   "Hide the modeline in `dired-mode'."
;;   (setq mode-line-format nil))

;; (add-hook 'dired-mode-hook 'hide-modeline-in-dired-mode)

;; (defun hide-modeline-in-vterm-mode ()
;;   "Hide the modeline in `vterm-mode'."
;;   (setq mode-line-format nil))

;; (add-hook 'vterm-mode-hook 'hide-modeline-in-vterm-mode)
#+end_src
** toolbar
#+begin_src emacs-lisp
(tool-bar-mode  -1)
(scroll-bar-mode  -1)
(menu-bar-mode  -1)
#+end_src
** smooth-scrolling
#+begin_src emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don"t accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
(setq scroll-step 1) ;; keyboard scroll one line at a time
(setq scroll-conservatively 10000)
(setq auto-window-vscroll nil)
#+end_src
** scrollbar
#+begin_src emacs-lisp
(toggle-scroll-bar -1)
#+end_src
** raibow-delimiters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** trasparency / opacity
set trasparency of emacs
when focused and not focused
#+begin_src emacs-lisp
(set-frame-parameter (selected-frame) 'alpha '(95 100))
(add-to-list 'default-frame-alist '(alpha 95 100))


;; (add-to-list 'default-frame-alist '(alpha-background . 90))
#+end_src
* FONT
TODO
- variables [] (OCR B)
** Doom
Settings related to fonts within Doom Emacs:
+ 'doom-font' -- standard monospace font that is used for most things in Emacs.
+ 'doom-variable-pitch-font' -- variable font which is useful in some Emacs plugins.
+ 'doom-big-font' -- used in doom-big-font-mode; useful for presentations.
+ 'font-lock-comment-face' -- for comments.
+ 'font-lock-keyword-face' -- for keywords with special significance like 'setq' in elisp.
#+BEGIN_SRC emacs-lisp
(setq doom-font (font-spec :family "JetBrains Mono NF ExtraBold" :size 15) ;; :height 1.1)
      doom-variable-pitch-font (font-spec :family "Ubuntu" :size 15)
      doom-big-font (font-spec :family "JetBrains Mono" :size 24))
(after! doom-themes
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t))
(custom-set-faces!
  '(font-lock-comment-face :slant italic)
  '(font-lock-keyword-face :slant italic))
#+END_SRC
** Dired
#+begin_src emacs-lisp
;; (defun use-ocr-b-bold ()
;;   "Switch the current buffer to the OCR B-Bold font."
;;   (face-remap-add-relative 'default '(:family "JetBrains Mono NF ExtraBold" :height 130)))

;; (add-hook 'dired-mode-hook 'use-ocr-b-bold)


;; (defun use-jetbrains-mono-extrabold ()
;;   "Switch the current buffer to JetBrains Mono ExtraBold font."
;;   (interactive)
;;   (message "Running use-jetbrains-mono-extrabold...")
;;   (face-remap-add-relative 'default '(:family "JetBrains Mono ExtraBold" :height 130)))

;; (with-eval-after-load 'dired
;;   (add-hook 'dired-mode-hook 'use-jetbrains-mono-extrabold))

#+end_src
** Minibuffer
*** Default
adding a function to minibuffer-setup-hook, which Emacs runs every time the minibuffer is entered
#+begin_src emacs-lisp
(defun set-minibuffer-font ()
  "Set the font for the minibuffer."
  (face-remap-add-relative 'default '(:family "JetBrains Mono NF ExtraBold" :height 100)))

(add-hook 'minibuffer-setup-hook 'set-minibuffer-font)
#+end_src
*** Prompt
#+begin_src emacs-lisp
(custom-set-faces
  '(minibuffer-prompt ((t (:family "JetBrains Mono NF ExtraBold" :height 120)))))
#+end_src
** Org
#+begin_src emacs-lisp
;; (defun my-set-org-mode-font ()
;;   "Set the font to JetBrains Mono NF ExtraBold when in org mode."
;;   (interactive)
;;   (when (derived-mode-p 'org-mode)
;;     (setq buffer-face-mode-face '(:family "JetBrains Mono NF ExtraBold" :height 1.1)) ;;  NF ExtraBold
;;     (buffer-face-mode)))

;; (add-hook 'org-mode-hook 'my-set-org-mode-font)
#+end_src
** Markdown
#+begin_src emacs-lisp
(defun my-set-markdown-mode-font ()
  "Set the font to JetBrains Mono NF ExtraBold when in markdown mode."
  (interactive)
  (when (derived-mode-p 'markdown-mode)
    (setq buffer-face-mode-face '(:family "JetBrains Mono NF ExtraBold" :height 1.1))
    (buffer-face-mode)))

(add-hook 'markdown-mode-hook 'my-set-markdown-mode-font)
#+end_src
** Python
set everything
#+begin_src emacs-lisp
(defun my-set-python-mode-font ()
  "Set the font to Space Mono when in python mode."
  (interactive)
  (when (derived-mode-p 'python-mode)
    (setq buffer-face-mode-face '(:family "jetbrains mono nl extrabold" :height 1.3)) ;; Ubuntu Mono
    (buffer-face-mode)))

(add-hook 'python-mode-hook 'my-set-python-mode-font)
#+end_src
* Dashboard
** scroll
fix the scroll
#+begin_src emacs-lisp
(defun my/dashboard-setup ()
  "Setup for dashboard."
  (my/dashboard-bindings)
  ;; Make the cursor invisible in dashboard
  ;; (setq-local cursor-type nil)
  ;; Disable mouse scrolling
  (setq-local mouse-wheel-scroll-amount '(nil))
  (setq-local mouse-wheel-progressive-speed nil)
  ;; Turn off evil-mode in this buffer
  (evil-local-mode -1))

(add-hook 'dashboard-mode-hook 'my/dashboard-setup)
#+end_src
** Highlight
#+begin_src emacs-lisp
(defvar my/current-highlight-overlay nil
  "Overlay variable for current highlighted line.")

(defun my/dashboard-widget-forward (&optional arg)
  "Move point to the next field or button in the current buffer.
ARG is passed as an argument to 'widget-forward'.
Then apply highlighting to the current widget."
  (interactive "p")
  (widget-forward arg)
  (my/dashboard-highlight-widget))

(defun my/dashboard-widget-backward (&optional arg)
  "Move point to the previous field or button in the current buffer.
ARG is passed as an argument to 'widget-backward'.
Then apply highlighting to the current widget."
  (interactive "p")
  (widget-backward arg)
  (my/dashboard-highlight-widget))

(defun my/dashboard-highlight-widget ()
  "Highlight the current widget with overlay."
  (when-let ((widget (widget-at)))
    ;; Clear previous highlight
    (when my/current-highlight-overlay
      (delete-overlay my/current-highlight-overlay))
    ;; Create new highlight overlay only if the line is not empty
    (unless (looking-at-p "[[:space:]]*$")
      (let* ((start (progn (skip-chars-forward " \t") (point)))
             (end (point-at-eol))
             (overlay (make-overlay start end)))
        (overlay-put overlay 'face 'highlight)
        ;; Store new overlay
        (setq my/current-highlight-overlay overlay)))))

(defun my/dashboard-bindings ()
  "Add my keybindings for dashboard."
  (map! :map dashboard-mode-map
        :n "j" #'my/dashboard-widget-forward
        :n "k" #'my/dashboard-widget-backward
        :n "l" #'widget-button-press
        :n "h" #'ignore))

(defun my/dashboard-setup ()
  "Setup for dashboard."
  (my/dashboard-bindings)
  ;; Make the cursor invisible in dashboard
  (setq-local cursor-type nil))

(add-hook 'dashboard-mode-hook 'my/dashboard-setup)

#+end_src
** Conf
#+begin_src emacs-lisp
(require 'dashboard)
(setq dashboard-startup-banner "~/xos/emacs/dashboard/xos-logo.png") ;; logo

(setq dashboard-center-content t)
(setq dashboard-show-shortcuts nil)

;; Set the title
(setq dashboard-banner-logo-title "Welcome to Emacs Dashboard")

;; Set the footer
(setq dashboard-footer-icon (all-the-icons-octicon "dash" :height 1.1 :v-adjust -0.05 :face 'font-lock-keyword-face))
(setq dashboard-footer-messages '("Dashboard is a minimal and nice looking startup screen."))

;; Set the content
(setq dashboard-items '((recents  . 5)
                        (projects . 5)))

;; Enable the dashboard at startup
(dashboard-setup-startup-hook)

;; Config for recent files
(require 'recentf)
(setq recentf-exclude '("/tmp/" "/ssh:"))
(setq recentf-max-saved-items 50)
(recentf-mode 1)

;; Config for projectile
(require 'projectile)
(setq projectile-completion-system 'ivy)
(projectile-mode 1)

;; Define the function to open the dashboard manually
(defun open-dashboard ()
  (interactive)
  (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*"))))
(global-set-key (kbd "C-x d") 'dashboard-open)
#+end_src
** Keybinds
keybind within the dashboard
#+begin_src emacs-lisp
;; (defun my/dashboard-bindings ()
;;   "Add my keybindings for dashboard."
;;   (map! :map dashboard-mode-map
;;         :n "l" #'widget-button-press
;;         :n "h" #'ignore))
;;         :n "j" #'widget-forward
;;         :n "k" #'widget-backward

;; (add-hook 'dashboard-mode-hook 'my/dashboard-bindings)


;; (map! :map dashboard-mode-map
;;         "<mouse-4>" #'my/dashboard-widget-forward
;;         "<mouse-5>" #'my/dashboard-widget-backward
;;         :n "l" #'widget-button-press
;;         :n "h" #'ignore)

#+end_src
** Initial-buffer
Set dashboard as the initial buffer
#+begin_src emacs-lisp
;; (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))


;; (defun open-dashboard ()
;;   (interactive)
;;   (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*"))))
;; (global-set-key (kbd "C-x d") 'dashboard-open)




(setq initial-buffer-choice nil)

(defun open-dashboard ()
  "Open the dashboard."
  (interactive)
  (dashboard-refresh-buffer))

;; (defun generate-image-and-open-dashboard ()
;;   "Generate image and open dashboard."
;;   (shell-command "python3 ~/xos/pywal-scripts/dashboard-wal-gen.py")
;;   (open-dashboard))

(add-hook 'after-init-hook (lambda () (run-at-time "0.5 sec" nil 'generate-image-and-open-dashboard)))


#+end_src
* Keybinds
** Open
*** Ielm
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("o" . "open")
        :desc "ielm repl" "i" #'ielm))

#+end_src
** Kill
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("k" . "kill")
        :desc "process" "p" #'kill-process))
#+end_src
** Edwina
#+begin_src emacs-lisp


(after! evil
  (define-key evil-normal-state-map (kbd "M-<return>") #'vterm/toggle))

(after! edwina
  (define-key edwina-mode-map (kbd "M-<return>") #'vterm/toggle))
#+end_src
** Global-set-key
#+begin_src emacs-lisp
;; (global-set-key (kbd "M-<return>") #'vterm/toggle)
#+end_src
** File-jump
#+begin_src emacs-lisp
(map! :leader
      "f j" (lambda ()
              (interactive)
              (let ((selected-file (read-file-name "Open file: ")))
                (split-window-right) ; Split the window to the right
                (other-window 1) ; Move to the newly created window
                (find-file selected-file))))

#+end_src
** Ranger
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("d" . "directory")
        :desc "ranger" "k" #'ranger))
#+end_src
** Diff
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("d" . "diff")
        :desc "diff buffer with file" "i" #'laluxx/diff-buffer-with-file))


#+end_src
** Regex
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("r" . "regexp")
        :desc "Regex builder" "b" #'re-builder))

(map! :leader
      (:prefix ("r" . "regexp")
        :desc "counsel-rg" "g" #'counsel-rg))

#+end_src
** Toggle
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("t" . "Toggle")
       :desc "Toggle truncated lines" "t" #'visual-line-mode))
#+end_src
** Org
*** block-jump
if inside a src code block
shift + j -> cursor at the end of the code block
shift + k -> cursor at the start of the code block
#+begin_src emacs-lisp
(defun my/org-beginning-of-src-block ()
  "Move point to the beginning of the current source block."
  (interactive)
  (when (org-in-src-block-p)
    (search-backward "#+begin_src")
    (forward-line)
    (beginning-of-line)))

(defun my/org-end-of-src-block ()
  "Move point to the end of the current source block."
  (interactive)
  (when (org-in-src-block-p)
    (search-forward "#+end_src")
    (backward-char 11)))

(defun my/org-src-keybindings ()
  "Setup keybindings for org-src-mode."
  (when (org-in-src-block-p)
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "M-k") 'my/org-beginning-of-src-block)
      (define-key map (kbd "M-j") 'my/org-end-of-src-block)
      (set-transient-map map t))))

(add-hook 'org-mode-hook 'my/org-src-keybindings)

(with-eval-after-load 'evil-maps
  (define-key evil-visual-state-map (kbd "M-k") 'my/org-beginning-of-src-block)
  (define-key evil-visual-state-map (kbd "M-j") 'my/org-end-of-src-block))

#+end_src
*** Shifttab
#+begin_src emacs-lisp
;; MAIN
(defun my/org-shifttab-advice (orig-fun &rest args)
  "Always use global cycling with `org-shifttab'."
  (let ((context (org-element-lineage
                  (org-element-context)
                  '(headline inlinetask) t)))
    (if (or (not context)
            (eq 'headline (org-element-type context)))
        (apply 'org-global-cycle args)
      (apply orig-fun args))))

(advice-add 'org-shifttab :around 'my/org-shifttab-advice)


(defun my/org-shifttab-or-beginning-of-line ()
  "Call org-shifttab, then move to the beginning of the line."
  (interactive)
  (org-shifttab)
  (run-at-time "0.3 sec" nil #'beginning-of-line))

(with-eval-after-load 'org
  (define-key org-mode-map (kbd "<backtab>") #'my/org-shifttab-or-beginning-of-line))


#+end_src
*** Evil
open org bullets with =l= and close them with =h=
#+begin_src emacs-lisp
(defun my-org-cycle-or-move-right ()
  (interactive)
  (if (and (bolp) (org-at-heading-p))
      (org-cycle)
    (evil-forward-char 1)))

(defun my-org-close-or-move-left ()
  (interactive)
  (if (and (bolp) (org-at-heading-p))
      (outline-hide-subtree)
    (evil-backward-char 1)))

(add-hook 'org-mode-hook
          (lambda ()
            (evil-define-key 'normal org-mode-map
              (kbd "l") 'my-org-cycle-or-move-right)
            (evil-define-key 'normal org-mode-map
              (kbd "h") 'my-org-close-or-move-left)))
#+end_src
*** Mouse
#+begin_src emacs-lisp
;; OVERLAY DONE
(defvar org-headline-overlay nil)
(defvar org-last-highlighted-line nil)

(defun org-highlight-headline ()
  (when (org-at-heading-p)
    (if org-headline-overlay
        (move-overlay org-headline-overlay (line-beginning-position) (line-end-position))
      (setq org-headline-overlay (make-overlay (line-beginning-position) (line-end-position))))
    (overlay-put org-headline-overlay 'face 'highlight)
    (setq org-last-highlighted-line (line-number-at-pos))))

(defun org-unhighlight-headline ()
  (when org-headline-overlay
    (delete-overlay org-headline-overlay)))

(defun org-next-headline-or-wrap ()
  (interactive)
  (org-unhighlight-headline)
  (let ((initial-position (point)))
    (org-next-visible-heading 1)
    (when (= (point) initial-position)
      (goto-char (point-min))))
  (org-highlight-headline))

(defun org-previous-headline-or-wrap ()
  (interactive)
  (org-unhighlight-headline)
  (let ((initial-position (point)))
    (unless (and (eobp) (looking-at-p "^$"))
      (org-previous-visible-heading 1))
    (when (= (point) initial-position)
      (goto-char (point-max))
      (org-previous-visible-heading 1)))
  (org-highlight-headline))

(defun org-go-to-last-highlighted-line ()
  (interactive)
  (when org-last-highlighted-line
    (goto-line org-last-highlighted-line)
    (org-highlight-headline)))

(add-hook 'org-mode-hook
          (lambda ()
            (define-key org-mode-map (kbd "<S-mouse-4>") 'org-previous-headline-or-wrap)
            (define-key org-mode-map (kbd "<S-mouse-5>") 'org-next-headline-or-wrap)
            (define-key org-mode-map (kbd "<S-mouse-2>") 'org-go-to-last-highlighted-line)
            (define-key org-mode-map (kbd "<S-mouse-8>") 'org-cycle)
            (define-key org-mode-map (kbd "<M-mouse-4>") 'previous-line)
            (define-key org-mode-map (kbd "<M-mouse-5>") 'next-line)
            (define-key org-mode-map (kbd "M-C-j") 'org-next-headline-or-wrap)
            (define-key org-mode-map (kbd "M-C-k") 'org-previous-headline-or-wrap)
            (define-key org-mode-map (kbd "<S-mouse-9>") (lambda () (interactive) (org-cycle t)))))
#+end_src
*** Insert-header-tags
#+begin_src emacs-lisp
(map! :leader
      :desc "Insert header tags"
      "i o" #'org-insert-header-tags)
#+end_src
*** Jump
#+begin_src emacs-lisp
(map! :leader
      :desc "Jump to tangled file"
      "o j" #'org-jump-to-tangled)
#+end_src
*** Split-jump
Jump, vsplit and set zoom if tangled file exist
#+begin_src emacs-lisp
(map! :leader
      :desc "Split and jump to tangled file with zoom"
      "o J" #'org-jump-to-tangled-split-and-zoom)
#+end_src
** Shells
#+begin_src emacs-lisp
(map! :leader
      :desc "Eshell"                 "e s" #'eshell
      :desc "Eshell popup toggle"    "t e" #'+eshell/toggle
      :desc "Counsel eshell history" "e h" #'counsel-esh-history
      :desc "Vterm popup toggle"     "v t" #'+vterm/toggle)
#+end_src
** Doom overwrite
#+begin_src emacs-lisp
(map! :leader
      :desc "Kill buffer and open dashboard if last buffer"
      "b k" 'kill-buffer-and-maybe-open-dashboard)
#+end_src
** General-key
Keybinds that execute other keybinds.
*** Dir-split-jump
#+begin_src emacs-lisp
(map! :leader
      :desc "Custom Keybind"
      "d J" (lambda ()
              (interactive)

              ;; (text-scale-set -1)  ;; Set the desired zoom level here
              (execute-kbd-macro (kbd "SPC w v"))
              (execute-kbd-macro (kbd "SPC d j"))))
#+end_src
** Dmenu
#+begin_src emacs-lisp
(global-set-key (kbd "M-p") 'dmenu)
#+end_src
** HELP
*** Hooks
#+begin_src emacs-lisp
(map! :leader
      :desc "Show all hooks"
      "hh" #'laluxx/list-hooks)
#+end_src

* FUNCTIONS
** Dynamic-modeline
#+begin_src emacs-lisp
;; V1
;; if i alway open new buffer it works virtually perfect
;; we have to be sure to disable the modeline for that window
;; so the other buffers could still have it if their position say so

(defun window-touches-bottom-p (win)
  "Check if WIN is touching the bottom of the frame."
  (let* ((edges (window-edges win nil t t))
         (bottom-edge (nth 3 edges))
         (frame-height (frame-pixel-height))
         ;; Define a tolerance of 10 pixels
         (tolerance 10))
    ;; Check if the window's bottom edge is within the tolerance of the frame's height
    (<= (abs (- bottom-edge frame-height)) tolerance)))

(defun adjust-modelines-based-on-geometry ()
  "Adjust modelines based on window geometry."
  (dolist (win (window-list))
    (with-selected-window win
      (if (window-touches-bottom-p win)
          (setq-local mode-line-format (default-value 'mode-line-format))
        (setq-local mode-line-format nil)))))

(add-hook 'window-configuration-change-hook 'adjust-modelines-based-on-geometry)






#+end_src
** Insert-nerd-font-icon
TODO
- it doesn't work []
#+begin_src emacs-lisp
;; (require 'url)
;; (require 'dom)

;; (defun fetch-nerd-font-icons ()
;;   "Fetch Nerd Font icons from their cheat sheet and return them as an alist."
;;   (let ((url "https://www.nerdfonts.com/cheat-sheet")
;;         icons)
;;     (with-temp-buffer
;;       (url-insert-file-contents url)
;;       (let ((dom (libxml-parse-html-region (point-min) (point-max))))
;;         (dolist (icon (dom-by-class dom "column"))
;;           (let ((icon-name (dom-text (car (dom-by-class icon "mdi-label"))))
;;                 (codepoint (dom-text (car (dom-by-class icon "mdi-codepoints")))))
;;             (push (cons icon-name codepoint) icons)))))
;;     icons))

;; (defun insert-nerd-font-icon ()
;;   "Prompt with ivy to select a Nerd Font icon and insert it."
;;   (interactive)
;;   (let ((icons (fetch-nerd-font-icons)))
;;     (ivy-read "Select Nerd Font icon: "
;;               icons
;;               :action (lambda (pair)
;;                         (insert (cdr pair))))))



;; (map! :leader
;;       :desc "Insert Nerd Font Icon" "in" #'insert-nerd-font-icon)
#+end_src
** Minibuffer-counter
#+begin_src emacs-lisp
(defvar top-counter 0
  "Counter for touches at the beginning of the buffer.")
(defvar bottom-counter 0
  "Counter for touches at the end of the buffer.")
(defvar last-command-was-gg-or-G nil
  "Flag to check if the previous command was `gg` or `G` in evil mode.")

(defun interpolate-color (value max-value start-color end-color)
  "Interpolate between START-COLOR and END-COLOR based on VALUE out of MAX-VALUE."
  (let ((fraction (/ (float value) max-value)))
    (cl-loop for start from 0 to 2
             collect (round (+ (* (nth start start-color) (- 1 fraction))
                               (* (nth start end-color) fraction))))))

(defun counter-color (value)
  "Calculate the color based on the counter VALUE."
  (let* ((green '(0 255 0))
         (red '(255 0 0))
         (color (interpolate-color value 100 green red)))
    (apply 'format "#%02x%02x%02x" color)))

(defun display-counter (counter position)
  "Display the COUNTER in the minibuffer with interpolated color for a specific POSITION ('top or 'bottom)."
  (let ((color (counter-color counter)))
    (message (propertize (format "%s Counter: %d" (capitalize (symbol-name position)) counter)
                         'face `(:foreground ,color)))))

(defun check-end-or-start-of-buffer ()
  "Check if point is at the end or start of the buffer and update the corresponding counter."
  (unless (or (minibufferp) (string= (buffer-name) "*dashboard*"))
    (cond
     ;; At the bottom of the buffer
     ((eobp)
      (if (eq last-command-was-gg-or-G 'G)
          (progn
            (message "%s End of buffer" (all-the-icons-faicon "arrow-down"))
            (setq bottom-counter 0))
        (setq bottom-counter (min 100 (1+ bottom-counter)))
        (display-counter bottom-counter 'bottom)))
     ;; At the top of the buffer
     ((or (bobp) (eq last-command-was-gg-or-G 'gg))
      (if (eq last-command-was-gg-or-G 'gg)
          (message "%s Start of buffer" (all-the-icons-faicon "arrow-up"))
        (setq top-counter (min 100 (1+ top-counter)))
        (display-counter top-counter 'top)))
     ;; Not at the top or bottom; reset counters and minibuffer.
     (t
      (setq top-counter 0 bottom-counter 0)
      (message ""))))

  ;; Reset the last-command flag
  (setq last-command-was-gg-or-G nil)


  ;; Reset the last-command flag
  (setq last-command-was-gg-or-G nil))

(defun detect-gg-or-G-command ()
  "Check and record if the command about to execute is `gg` or `G`."
  (cond
   ((eq this-command 'evil-goto-first-line)
    (setq last-command-was-gg-or-G 'gg))
   ((eq this-command 'evil-goto-line)
    (setq last-command-was-gg-or-G 'G))))

(add-hook 'post-command-hook 'check-end-or-start-of-buffer)
(add-hook 'pre-command-hook 'detect-gg-or-G-command)

#+end_src
** Set-theme
#+begin_src emacs-lisp
;; (defun laluxx/preview-theme ()
;;   "Preview theme as you scroll through options in counsel-load-theme."
;;   (interactive)
;;   (let* ((themes (custom-available-themes))
;;          (theme-names (mapcar 'symbol-name themes))
;;          (current-theme (car custom-enabled-themes))
;;          (previewed-theme nil)
;;          (ivy-update-fn
;;           (lambda ()
;;             (when previewed-theme
;;               (disable-theme previewed-theme))
;;             (setq previewed-theme (intern (ivy-state-current ivy-last)))
;;             (load-theme previewed-theme t))))
;;     (ivy-read "Load theme: " theme-names
;;               :update-fn ivy-update-fn
;;               :action
;;               (lambda (theme)
;;                 (load-theme (intern theme) t))
;;               :caller 'laluxx/preview-theme)))


;; (defun laluxx/preview-theme ()
;;   "Preview theme as you scroll through options in counsel-load-theme."
;;   (interactive)
;;   (let* ((themes (custom-available-themes))
;;          (theme-names (mapcar 'symbol-name themes))
;;          (current-theme (car custom-enabled-themes))
;;          (previewed-theme nil)
;;          (ivy-update-fn
;;           (lambda ()
;;             (when previewed-theme
;;               (disable-theme previewed-theme))
;;             (setq previewed-theme (intern (ivy-state-current ivy-last)))
;;             (load-theme previewed-theme t)
;;             ;; Add powerline-reset here
;;             (powerline-reset))))
;;     (ivy-read "Load theme: " theme-names
;;               :update-fn ivy-update-fn
;;               :action
;;               (lambda (theme)
;;                 (load-theme (intern theme) t))
;;               :caller 'laluxx/preview-theme)))


(defun laluxx/preview-theme ()
  "Preview theme as you scroll through options in counsel-load-theme."
  (interactive)
  (let* ((themes (custom-available-themes))
         (theme-names (mapcar 'symbol-name themes))
         (current-theme (car custom-enabled-themes))
         (previewed-theme nil)
         (ivy-update-fn
          (lambda ()
            ;; Disable all active themes
            (mapc #'disable-theme custom-enabled-themes)

            (setq previewed-theme (intern (ivy-state-current ivy-last)))
            (load-theme previewed-theme t)
            ;; Add powerline-reset here
            (powerline-reset))))
    (ivy-read "Load theme: " theme-names
              :update-fn ivy-update-fn
              :action
              (lambda (theme)
                (load-theme (intern theme) t))
              :caller 'laluxx/preview-theme)))


(defun laluxx/set-theme-and-update-environment ()
  "Function to set a new Doom theme and then update the environment according to the new theme."
  (interactive)
  ;; Define directories
  (let* ((pywal-scripts-directory "~/xos/pywal-scripts")
         (current-buffer-name (buffer-name))
         ;; Get the WM name
         (wm-name (string-trim (shell-command-to-string "wmctrl -m | awk 'NR==1 {print $2}'"))))
    ;; Load the theme using the same mechanism as h t
    (laluxx/preview-theme)
    ;; (laluxx/doom-wal)
    ;; Then run all the other commands you wanted to run
    (dolist (script '("xmonad-dark-wal.py" "nvim-wal.py" "nvim-wal-dark.py"))
      (shell-command-to-string (concat "python3 " pywal-scripts-directory "/" script)))
    ;; Check the WM name and execute the appropriate command
    (cond
     ((string-equal wm-name "LG3D") (shell-command-to-string "xmonad --restart"))
     ((string-equal wm-name "dwm") (shell-command-to-string "xdotool key super+F5")))
    (shell-command-to-string "dashboard-wal-gen")
    ;; If the current buffer was the dashboard, refresh it
    (when (equal current-buffer-name "*dashboard*")
      (run-at-time "0.5 sec" nil 'open-dashboard))
    (run-at-time "1 sec" nil 'powerline-reset)))

;; Map the function to a key sequence
(map! :leader
      :desc "Set theme and update environment"
      "h t" #'laluxx/set-theme-and-update-environment)

(map! :leader
      :desc "Set wallpaper and update environment"
      "h T" #'laluxx/wal-set)
#+end_src

** Toggle-highlight
#+begin_src emacs-lisp
(after! hl-line
  ;; Define a function to toggle line highlight in current buffer
  (defun my/toggle-local-hl-line ()
    (interactive)
    (if hl-line-mode
        (hl-line-mode -1)
      (hl-line-mode 1)))

  ;; Define a function to toggle line highlight globally
  (defun my/toggle-global-hl-line ()
    (interactive)
    (if global-hl-line-mode
        (global-hl-line-mode -1)
      (global-hl-line-mode 1))))

(map! :leader
      (:prefix ("t" . "toggle")
       :desc "Toggle hl-line in current buffer" "h" #'my/toggle-local-hl-line
       :desc "Toggle global hl-line" "H" #'my/toggle-global-hl-line))
#+end_src
** Wal-Set
*** Default
TODO:
- it doesnt refresh the dashboard if is
  opened in a split and not focused []
#+begin_src emacs-lisp
;; (defun laluxx/wal-set ()
;;   (interactive)
;;   (let* ((default-directory "~/xos/wallpapers/static")
;;          (theme-directory "~/xos/theme")
;;          (pywal-scripts-directory "~/xos/pywal-scripts")
;;          (image-files (directory-files-recursively default-directory "\\.\\(png\\|jpg\\|jpeg\\|webp\\)$"))
;;          (current-buffer-name (buffer-name)))  ; Save the current buffer name
;;     (ivy-read "Choose wallpaper: "
;;               image-files
;;               :action (lambda (wallpaper)
;;                         (when (and (not (string-empty-p wallpaper))
;;                                    (file-exists-p wallpaper))
;;                           (let ((abs-wallpaper (expand-file-name wallpaper)))
;;                             (shell-command-to-string (concat "wal -i " abs-wallpaper))
;;                             (with-temp-file (concat theme-directory "/.wallpaper")
;;                               (insert abs-wallpaper))
;;                             (shell-command-to-string "theme pywal --no-random")
;;                             (dolist (script '("xmonad-dark-wal.py" "nvim-wal.py" "nvim-wal-dark.py"))
;;                               (shell-command-to-string (concat "python3 " pywal-scripts-directory "/" script)))
;;                             (shell-command-to-string "xmonad --restart")
;;                             (shell-command-to-string "dashboard-wal-gen")
;;                             ;; If the current buffer was the dashboard, refresh it
;;                             (when (equal current-buffer-name "*dashboard*")
;;                               (run-at-time "0.5 sec" nil 'open-dashboard))
;;                             (run-at-time "1 sec" nil 'spaceline-compile)))))))


;; (defun laluxx/wal-set ()
;;   (interactive)
;;   (let* ((default-directory "~/xos/wallpapers/static")
;;          (theme-directory "~/xos/theme")
;;          (pywal-scripts-directory "~/xos/pywal-scripts")
;;          (image-files (directory-files-recursively default-directory "\\.\\(png\\|jpg\\|jpeg\\|webp\\)$"))
;;          (current-buffer-name (buffer-name))
;;          (wm-name (string-trim (shell-command-to-string "wmctrl -m | awk 'NR==1 {print $2}'"))))
;;     (ivy-read "Choose wallpaper: "
;;               image-files
;;               :action (lambda (wallpaper)
;;                         (when (and (not (string-empty-p wallpaper))
;;                                    (file-exists-p wallpaper))
;;                           (let ((abs-wallpaper (expand-file-name wallpaper)))
;;                             (shell-command-to-string (concat "wal -i " abs-wallpaper))
;;                             (with-temp-file (concat theme-directory "/.wallpaper")
;;                               (insert abs-wallpaper))
;;                             (shell-command-to-string "theme pywal --no-random")
;;                             (dolist (script '("xmonad-dark-wal.py" "nvim-wal.py" "nvim-wal-dark.py"))
;;                               (shell-command-to-string (concat "python3 " pywal-scripts-directory "/" script)))
;;                             (cond
;;                              ((string-equal wm-name "LG3D") (shell-command-to-string "xmonad --restart"))
;;                              ((string-equal wm-name "dwm") (shell-command-to-string "xdotool key super+F5")))
;;                             (shell-command-to-string "dashboard-wal-gen")
;;                             ;; If the current buffer was the dashboard, refresh it
;;                             (when (equal current-buffer-name "*dashboard*")
;;                               (run-at-time "0.5 sec" nil 'open-dashboard))
;;                             (run-at-time "1 sec" nil 'spaceline-compile)))))))


(defun laluxx/wal-set ()
  (interactive)
  (let* ((default-directory "~/xos/wallpapers/static")
         (theme-directory "~/xos/theme")
         (pywal-scripts-directory "~/xos/pywal-scripts")
         (image-files (directory-files-recursively default-directory "\\.\\(png\\|jpg\\|jpeg\\|webp\\)$"))
         (current-buffer-name (buffer-name))
         (wm-name (string-trim (shell-command-to-string "wmctrl -m | awk 'NR==1 {print $2}'"))))
    (ivy-read "Choose wallpaper: "
              image-files
              :action (lambda (wallpaper)
                        (when (and (not (string-empty-p wallpaper))
                                   (file-exists-p wallpaper))
                          (let ((abs-wallpaper (expand-file-name wallpaper)))
                            (shell-command-to-string (concat "wal -i " abs-wallpaper))
                            (with-temp-file (concat theme-directory "/.wallpaper")
                              (insert abs-wallpaper))
                            (shell-command-to-string "theme pywal --no-random")
                            (dolist (script '("xmonad-dark-wal.py" "nvim-wal.py" "nvim-wal-dark.py"))
                              (shell-command-to-string (concat "python3 " pywal-scripts-directory "/" script)))
                            (cond
                             ((string-equal wm-name "LG3D") (shell-command-to-string "xmonad --restart"))
                             ((string-equal wm-name "dwm") (shell-command-to-string "xdotool key super+F5")))
                            (shell-command-to-string "dashboard-wal-gen")
                            ;; Start picom
                            (start-process "picom" nil "picom")
                            ;; If the current buffer was the dashboard, refresh it
                            (when (equal current-buffer-name "*dashboard*")
                              (run-at-time "0.5 sec" nil 'open-dashboard))
                            (run-at-time "1 sec" nil 'spaceline-compile)))))))



#+end_src
*** Animated
#+begin_src emacs-lisp


(defun laluxx/wal-set-animated ()
  "Set an animated wallpaper and configure theme based on it."
  (interactive)
  (let* ((default-directory "~/xos/wallpapers/animated")
         (theme-directory "~/xos/theme")
         (pywal-scripts-directory "~/xos/pywal-scripts")
         (video-files (directory-files-recursively default-directory "\\.\\(mp4\\|mkv\\|webm\\|avi\\)$"))
         (current-buffer-name (buffer-name)))
    (ivy-read "Choose animated wallpaper: "
              video-files
              :action (lambda (video)
                        (when (and (not (string-empty-p video))
                                   (file-exists-p video))
                          (let* ((abs-video (expand-file-name video))
                                 (first-frame-image (concat abs-video "-frame1.png")))
                            ;; Extract the first frame of the video
                            (shell-command (concat "ffmpeg -i " abs-video " -vframes 1 " first-frame-image))
                            ;; Use the extracted frame with `wal` to generate and set the theme (but not set as wallpaper)
                            (shell-command (concat "wal -n -i " first-frame-image))
                            ;; Rest of the commands similar to your wal-set function
                            (with-temp-file (concat theme-directory "/.wallpaper")
                              (insert first-frame-image))
                            (shell-command "theme pywal --no-random")
                            (dolist (script '("xmonad-dark-wal.py" "nvim-wal.py" "nvim-wal-dark.py"))
                              (shell-command (concat "python3 " pywal-scripts-directory "/" script)))
                            (shell-command "xmonad --restart")
                            (shell-command "dashboard-wal-gen")
                            (when (equal current-buffer-name "*dashboard*")
                              (run-at-time "0.5 sec" nil 'open-dashboard))
                            (run-at-time "1 sec" nil 'spaceline-compile)
                            ;; Finally, set the video as the animated wallpaper
                            (start-process "set-animated-wallpaper" nil "xwinwrap" "-o" "1.0" "-nf" "-ovr" "--"
                                           "mpv" "-wid" "WID" "--loop-file=inf" "--video-unscaled"
                                           "--no-terminal" "--no-audio" "--no-input-default-bindings"
                                           "--no-border" "--no-window-dragging" "--no-osc" "--no-osd-bar" abs-video)))))))



;; ORIGINAL Xmobar below
;; (defun laluxx/wal-set-animated ()
;;   (interactive)
;;   (let* ((default-directory "~/xos/wallpapers/animated")
;;          (theme-directory "~/xos/theme")
;;          (pywal-scripts-directory "~/xos/pywal-scripts")
;;          (video-files (directory-files-recursively default-directory "\\.\\(mp4\\|mkv\\|webm\\|avi\\)$"))
;;          (current-buffer-name (buffer-name)))
;;     (ivy-read "Choose animated wallpaper: "
;;               video-files
;;               :action (lambda (video)
;;                         (when (and (not (string-empty-p video))
;;                                    (file-exists-p video))
;;                           (let* ((abs-video (expand-file-name video))
;;                                  (first-frame-image (concat abs-video "-frame1.png")))
;;                             ;; Extract the first frame of the video
;;                             (shell-command-to-string (concat "ffmpeg -i " abs-video " -vframes 1 " first-frame-image))
;;                             ;; Use the extracted frame with `wal` to generate and set the theme (but not set as wallpaper)
;;                             (shell-command-to-string (concat "wal -n -i " first-frame-image))
;;                             ;; Rest of the commands similar to your wal-set function
;;                             (with-temp-file (concat theme-directory "/.wallpaper")
;;                               (insert first-frame-image))
;;                             (shell-command-to-string "theme pywal --no-random")
;;                             (dolist (script '("xmonad-dark-wal.py" "nvim-wal.py" "nvim-wal-dark.py"))
;;                               (shell-command-to-string (concat "python3 " pywal-scripts-directory "/" script)))
;;                             (shell-command-to-string "xmonad --restart")
;;                             (shell-command-to-string "dashboard-wal-gen")
;;                             (when (equal current-buffer-name "*dashboard*")
;;                               (run-at-time "0.5 sec" nil 'open-dashboard))
;;                             (run-at-time "1 sec" nil 'spaceline-compile)
;;                             ;; Finally, set the video as the animated wallpaper
;;                             (start-process "set-animated-wallpaper" nil "xwinwrap" "-o" "1.0" "-nf" "-ovr" "--"
;;                                            "mpv" "-wid" "WID" "--loop-file=inf" "--video-unscaled"
;;                                            "--no-terminal" "--no-audio" "--no-input-default-bindings"
;;                                            "--no-border" "--no-window-dragging" "--no-osc" "--no-osd-bar" abs-video)))))))


#+end_src
*** Favourite
Set a wal paper from =~/xos/wallpapers/favourites=
#+begin_src emacs-lisp
(defun laluxx/wal-set-favourite ()
  (interactive)
  (let* ((default-directory "~/xos/wallpapers/favourites")
         (theme-directory "~/xos/theme")
         (pywal-scripts-directory "~/xos/pywal-scripts")
         (image-files (directory-files-recursively default-directory "\\.\\(png\\|jpg\\|jpeg\\|webp\\)$")))
    (ivy-read "Favourite wallpapers: "
              image-files
              :action (lambda (wallpaper)
                        (when (and (not (string-empty-p wallpaper))
                                   (file-exists-p wallpaper))
                          (let ((abs-wallpaper (expand-file-name wallpaper)))
                            (shell-command-to-string (concat "wal -i " abs-wallpaper))
                            (with-temp-file (concat theme-directory "/.wallpaper")
                              (insert abs-wallpaper))
                            (shell-command-to-string "theme pywal --no-random")
                            (dolist (script '("xmonad-dark-wal.py" "nvim-wal.py" "nvim-wal-dark.py"))
                              (shell-command-to-string (concat "python3 " pywal-scripts-directory "/" script)))
                            (shell-command-to-string "xmonad --restart")
                            ;; (shell-command "papirus-wal")
                            ;; (shell-command-to-string "oomox-gtk-gen")
                            (shell-command-to-string "dashboard-wal-gen")
                            ;; (laluxx/load-org-wal-colors)
                            (run-at-time "1 sec" nil 'spaceline-compile)))))))  ; Delay spaceline-compile
#+end_src
*** solid
Choose a wal paper from =~/xos/wallpapers=
and turn it solid
#+begin_src emacs-lisp
(defun laluxx/wal-set-solid ()
  (interactive)
  (let* ((default-directory "~/xos/wallpapers/static")
         (theme-directory "~/xos/theme")
         (pywal-scripts-directory "~/xos/pywal-scripts")
         (solid-wallpapers-directory "~/xos/wallpapers/solid")
         (image-files (directory-files-recursively default-directory "\\.\\(png\\|jpg\\|jpeg\\|webp\\)$")))
    (ivy-read "Wallpapers to turn solid: "
              image-files
              :action (lambda (wallpaper)
                        (when (and (not (string-empty-p wallpaper))
                                   (file-exists-p wallpaper))
                          (let* ((abs-wallpaper (expand-file-name wallpaper))
                                 (base-wallpaper-name (file-name-base wallpaper))  ;; Get the filename without extension
                                 (solid-wallpaper (concat solid-wallpapers-directory "/" base-wallpaper-name "-SOLID.png")))
                            (if (file-exists-p solid-wallpaper)
                                (shell-command-to-string (concat "wal -i " solid-wallpaper))
                              (progn
                                (shell-command-to-string (concat "wal -n -i " abs-wallpaper)) ;; Use wal -n to generate colors without setting wallpaper
                                (shell-command-to-string (concat "wal-set-solid " base-wallpaper-name))))
                            (with-temp-file (concat theme-directory "/.wallpaper")
                              (insert abs-wallpaper))
                            (shell-command-to-string "theme pywal --no-random")
                            (dolist (script '("xmonad-dark-wal.py" "nvim-wal.py" "nvim-wal-dark.py"))
                              (shell-command-to-string (concat "python3 " pywal-scripts-directory "/" script)))
                            (shell-command-to-string "xmonad --restart")
                            (run-at-time "1 sec" nil 'spaceline-compile)))))))  ; Delay spaceline-compile
#+end_src

*** Set-wallpaper
set system wallpaper
#+begin_src emacs-lisp
(defun laluxx/set-wallpaper ()
  (interactive)
  (let* ((default-directory "~/xos/wallpapers/static")
         (image-files (directory-files-recursively default-directory "\\.\\(png\\|jpg\\|jpeg\\|webp\\)$")))
    (ivy-read "Choose wallpaper: "
              image-files
              :action (lambda (wallpaper)
                        (when (and (not (string-empty-p wallpaper))
                                   (file-exists-p wallpaper))
                          (let ((abs-wallpaper (expand-file-name wallpaper)))
                            (shell-command-to-string (concat "feh --bg-scale " abs-wallpaper))))))))
#+end_src
*** set-animated-wallpaper
simply set the video as the wallpaper without wal actions
#+begin_src emacs-lisp
;; work original
(defvar laluxx/last-animated-wallpaper nil "Path to the last set animated wallpaper.")

(defun laluxx/set-animated-wallpaper ()
  (interactive)
  (let* ((default-directory "~/xos/wallpapers/animated")
         (video-files (directory-files-recursively default-directory "\\.\\(mp4\\|mkv\\|webm\\|avi\\)$")))
    (ivy-read "Choose animated wallpaper: "
              video-files
              :action (lambda (video)
                        (when (and (not (string-empty-p video))
                                   (file-exists-p video))
                          (let ((abs-video (expand-file-name video)))
                            ;; Kill mpv if the new wallpaper is different from the last one
                            (when (not (equal abs-video laluxx/last-animated-wallpaper))
                              (shell-command "pkill mpv"))
                            (setq laluxx/last-animated-wallpaper abs-video)
                            (start-process "set-animated-wallpaper" nil "xwinwrap" "-o" "1.0" "-nf" "-ovr" "--"
                                           "mpv" "-wid" "WID" "--loop-file=inf" "--video-unscaled"
                                           "--no-terminal" "--no-audio" "--no-input-default-bindings"
                                           "--no-border" "--no-window-dragging" "--no-osc" "--no-osd-bar" abs-video)))))))
#+end_src
** update-dotfiles
whenever you save a file inside "~/Desktop/pulls/dotfiles"
or one of its subdirectories rsync it to HOME
#+begin_src emacs-lisp
(defun laluxx/update-dotfiles ()
  "Update dotfiles."
  (interactive)
  (let* ((dotfiles-path (expand-file-name "~/Desktop/pulls/dotfiles"))
         (command (concat "rsync -a " dotfiles-path "/. $HOME/")))
    (shell-command command)
    (message "Updated dotfiles")))

#+end_src
*** run-update-dotfiles
#+begin_src emacs-lisp
;; ONLY org
;; (defun laluxx/run-update-dotfiles ()
;;   "Run `laluxx/update-dotfiles` if the current file is inside ~/Desktop/pulls/dotfiles or its subdirectories."
;;   (when (and buffer-file-name
;;              (string-prefix-p (expand-file-name "~/Desktop/pulls/dotfiles") buffer-file-name)
;;              (string= (file-name-extension buffer-file-name) "org"))
;;     (laluxx/update-dotfiles)))

;; (add-hook 'after-save-hook 'laluxx/run-update-dotfiles)

;; ALL file extentions
(defun laluxx/run-update-dotfiles ()
  "Run `laluxx/update-dotfiles` if the current file is inside ~/Desktop/pulls/dotfiles or its subdirectories."
  (when (and buffer-file-name
             (string-prefix-p (expand-file-name "~/Desktop/pulls/dotfiles") buffer-file-name))
    (laluxx/update-dotfiles)))

(add-hook 'after-save-hook 'laluxx/run-update-dotfiles)


#+end_src
** Diff
#+begin_src emacs-lisp
  (defun laluxx/diff-buffer-with-file (&optional arg)
    "Compare buffer to its file, else run `vc-diff'.
With \\[universal-argument] also enable highlighting of word-wise
changes, local to the current buffer."
    (interactive "P")
    (let ((buf nil))     ; this method will "fail" if multi diff buffers
      (if (buffer-modified-p)
          (progn
            (diff-buffer-with-file (current-buffer))
            (setq buf "*Diff*"))
        (vc-diff)
        (setq buf "*vc-diff*"))
      (when arg
        (with-current-buffer (get-buffer buf)
          (setq-local diff-refine 'font-lock)))))
#+end_src
** emacs-Window-manager
*** Modes
**** Split-mode
#+begin_src emacs-lisp
(define-minor-mode laluxx/split-mode
  "A mode for custom splits."
  :lighter ""
  :init-value nil
  (if laluxx/split-mode
      (progn
        (setq buffer-read-only t
              cursor-type nil)
        (hide-mode-line-mode 1)
        (evil-define-key* 'normal 'local (kbd "v") 'vterm)
        (evil-define-key* 'insert 'local (kbd "v") 'vterm)
        (evil-define-key* 'visual 'local (kbd "v") 'vterm)
        (evil-define-key* 'normal 'local (kbd "q") 'delete-window)
        (evil-define-key* 'insert 'local (kbd "q") 'delete-window)
        (evil-define-key* 'visual 'local (kbd "q") 'delete-window))
    (progn
      (setq buffer-read-only nil
            cursor-type t)
      (hide-mode-line-mode -1))))

(defun laluxx/horizontal-split-and-hide-modeline ()
  "Horizontally split the window, create a new buffer, and turn on `laluxx/split-mode'."
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1)
  (switch-to-buffer (generate-new-buffer "new"))
  (laluxx/split-mode 1))

(defun laluxx/vertical-split-and-hide-modeline ()
  "Vertically split the window, create a new buffer, and turn on `laluxx/split-mode'."
  (interactive)
  (split-window-right)
  (other-window 1)
  (switch-to-buffer (generate-new-buffer "new"))
  (laluxx/split-mode 1))

(map! :leader
      (:prefix ("w" . "window")
       "s" #'laluxx/horizontal-split-and-hide-modeline
       "v" #'laluxx/vertical-split-and-hide-modeline))

#+end_src

*** Highlight
a function that highlight the selected window
#+begin_src emacs-lisp
;; IF YOU WANT TO BURN YOUR EYES
;; (defun highlight-selected-window ()
;;   "Highlight selected window with a different background color."
;;   (walk-windows (lambda (w)
;;                   (unless (or (eq w (selected-window)) (minibufferp (window-buffer w)))
;;                     (with-current-buffer (window-buffer w)
;;                       (buffer-face-set '(:background "#f6f6f6"))))))
;;   (unless (minibufferp (window-buffer (selected-window)))
;;     (buffer-face-set 'default)))

;; (add-hook 'buffer-list-update-hook 'highlight-selected-window)


;; Main
;; (require 'color)

;; (defun highlight-selected-window ()
;;   "Highlight selected window with a different background color."
;;   (let ((bg (face-attribute 'default :background)))
;;     (walk-windows (lambda (w)
;;                     (unless (or (eq w (selected-window)) (minibufferp (window-buffer w)))
;;                       (with-current-buffer (window-buffer w)
;;                         (buffer-face-set `(:background ,(color-darken-name bg 35))))))))
;;   (unless (minibufferp (window-buffer (selected-window)))
;;     (buffer-face-set 'default)))

;; (add-hook 'buffer-list-update-hook 'highlight-selected-window)



;; FRINGE FIX
;; (defun highlight-selected-window ()
;;   "Highlight selected window with a different background color."
;;   (let ((bg (face-attribute 'default :background)))
;;     (walk-windows (lambda (w)
;;                     (if (eq w (selected-window))
;;                         (progn
;;                           (with-current-buffer (window-buffer w)
;;                             (buffer-face-set 'default))
;;                           (with-selected-window w
;;                             (set-face-attribute 'fringe nil :background bg)))
;;                       (with-current-buffer (window-buffer w)
;;                         (buffer-face-set `(:background ,(color-darken-name bg 35))))
;;                       (with-selected-window w
;;                         (set-face-attribute 'fringe nil :background (color-darken-name bg 35))))))))
;; (add-hook 'buffer-list-update-hook 'highlight-selected-window)


#+end_src
*** Keybinds
#+begin_src emacs-lisp

;; 2
;; (map! :map general-override-mode-map
;;       :n "M-j" #'my-switch-buffer-forward-or-other-window
;;       :n "M-k" #'my-switch-buffer-backward-or-other-window)


;; (after! edwina
;;   ;; Modify Edwina keybindings
;;   (define-key edwina-mode-map (kbd "M-h") 'toggle-neotree-or-adjust-master)
;;   (define-key edwina-mode-map (kbd "M-l") 'toggle-vterm-or-adjust-master)
;;   (define-key edwina-mode-map (kbd "M-j") 'rotate-window)
;;   (define-key edwina-mode-map (kbd "M-k") (lambda () (interactive) (dotimes (_ (- (length (window-list)) 1)) (rotate-window))))

;;   ;; Custom functions
;;   (defun toggle-neotree-or-adjust-master ()
;;     "Toggle Neotree if there's only one window. Otherwise, decrease the master window's factor."
;;     (interactive)
;;     (if (one-window-p t)
;;         (neotree-toggle)
;;       (edwina-dec-mfact)))

;;   (defun toggle-vterm-or-adjust-master ()
;;     "Toggle VTerm if there's only one window. Otherwise, increase the master window's factor."
;;     (interactive)
;;     (if (one-window-p t)
;;         (+vterm/toggle)
;;       (edwina-inc-mfact))))

;; (defun my-switch-buffer-forward-or-other-window ()
;;   (interactive)
;;   (if (one-window-p)
;;       (next-buffer)
;;     (other-window 1)))

;; (defun my-switch-buffer-backward-or-other-window ()
;;   (interactive)
;;   (if (one-window-p)
;;       (previous-buffer)
;;     (other-window -1)))

;; (after! evil
;;   (map! :n "M-j" #'my-switch-buffer-forward-or-other-window
;;         :n "M-k" #'my-switch-buffer-backward-or-other-window))

;; ;; Ensure M-j and M-k work in org-mode
;; (after! org
;;   (define-key org-mode-map (kbd "M-j") #'my-switch-buffer-forward-or-other-window)
;;   (define-key org-mode-map (kbd "M-k") #'my-switch-buffer-backward-or-other-window))

;; (map! :leader
;;       (:prefix ("w" . "window")
;;        "M" #'laluxx/window-single-toggle))
;; (map! "M-SPC" #'laluxx/window-single-toggle)
;; (map! "M-<backspace>" #'delete-window)
;; (map! :map evil-normal-state-map "M-w" #'delete-window)
;; (map! :leader "SPC" #'rotate-layout)
;; (global-set-key (kbd "M-<return>") #'vterm)
;; (global-set-key (kbd "M-q") #'delete-window)








;; BEST
(after! edwina
  ;; Modify Edwina keybindings
  (define-key edwina-mode-map (kbd "M-h") 'toggle-neotree-or-adjust-master)
  (define-key edwina-mode-map (kbd "M-l") 'toggle-vterm-or-adjust-master)
  (define-key edwina-mode-map (kbd "M-j") 'rotate-window)
  (define-key edwina-mode-map (kbd "M-k") (lambda () (interactive) (dotimes (_ (- (length (window-list)) 1)) (rotate-window))))

  ;; Custom functions
  (defun toggle-neotree-or-adjust-master ()
    "Toggle Neotree if there's only one window. Otherwise, decrease the master window's factor."
    (interactive)
    (if (one-window-p t)
        (neotree-toggle)
      (edwina-dec-mfact)))

  (defun toggle-vterm-or-adjust-master ()
    "Toggle VTerm if there's only one window. Otherwise, increase the master window's factor."
    (interactive)
    (if (one-window-p t)
        (+vterm/toggle)
      (edwina-inc-mfact))))

(defun my-switch-buffer-forward-or-other-window ()
  (interactive)
  (if (one-window-p)
      (next-buffer)
    (other-window 1)))

(defun my-switch-buffer-backward-or-other-window ()
  (interactive)
  (if (one-window-p)
      (previous-buffer)
    (other-window -1)))

(after! evil
  (map! :n "M-j" #'my-switch-buffer-forward-or-other-window
        :n "M-k" #'my-switch-buffer-backward-or-other-window))

(map! :leader
      (:prefix ("w" . "window")
       "M" #'laluxx/window-single-toggle))
(map! "M-SPC" #'laluxx/window-single-toggle)
(map! "M-<backspace>" #'delete-window)
(map! :map evil-normal-state-map "M-w" #'delete-window)
(map! :leader "SPC" #'rotate-layout)
(global-set-key (kbd "M-<return>") #'vterm)
(global-set-key (kbd "M-q") #'delete-window)
#+end_src
*** Modeline
TODO
- no modeline from the 3 buffer
#+begin_src emacs-lisp
;; (defun laluxx/setup-mode-line ()
;;   "Set up the mode line."
;;   (dolist (window (window-list))
;;     (with-selected-window window
;;       (if (or (not (window-in-direction 'left))
;;               (and (window-in-direction 'down)
;;                    (not (window-in-direction 'right))))
;;           (hide-mode-line-mode -1)
;;         (hide-mode-line-mode 1)))))

;; (add-hook 'buffer-list-update-hook 'laluxx/setup-mode-line)



;; (defun laluxx/setup-mode-line ()
;;   "Set up the mode line."
;   (let ((windows (window-list))
;;         (counter 1))
;;     (dolist (window windows)
;;       (with-selected-window window
;;         (if (<= counter 2)
;;             (setq mode-line-format (default-value 'mode-line-format))  ; show modeline
;;           (setq mode-line-format nil))  ; hide modeline
;;         (setq counter (1+ counter))))))

;; (add-hook 'buffer-list-update-hook 'laluxx/setup-mode-line)
#+end_src
*** Tall
#+begin_src emacs-lisp
(defun laluxx/create-tall-window ()
  "Create a new window for the tall layout."
  (interactive)
  (if (= (length (window-list)) 1)
      (laluxx/vertical-split-and-hide-modeline)
    (select-window (window-at (frame-width) 0))  ; Select the rightmost window
    (laluxx/horizontal-split-and-hide-modeline)))

(defvar laluxx/layouts
  '((:name tall
           :description "Master and stack layout"
           :new-window-function laluxx/create-tall-window)))

(defvar laluxx/current-layout (car laluxx/layouts)
  "Current layout for new windows.")

(defun laluxx/create-window-based-on-layout ()
  "Create a new window based on the current layout."
  (interactive)
  (let ((new-window-function (plist-get laluxx/current-layout :new-window-function)))
    (funcall new-window-function)))


;; (evil-global-set-key 'normal (kbd "<C-return>") #'laluxx/create-window-based-on-layout)
(evil-global-set-key 'normal (kbd "<M-return>") #'laluxx/create-window-based-on-layout)

#+end_src
*** Monocole
#+begin_src emacs-lisp
(defvar laluxx/window-configuration nil
  "Current window configuration.
Intended for use by `laluxx/window-single-toggle'.")

(define-minor-mode laluxx/window-single-toggle
  "Toggle between multiple windows and single window.
This is the equivalent of maximising a window.  Tiling window
managers such as DWM, BSPWM refer to this state as 'monocle'."
  :lighter " Monocle"
  :global nil
  (if (one-window-p)
      (when laluxx/window-configuration
        (set-window-configuration laluxx/window-configuration)
        (setq laluxx/window-configuration nil))
    (setq laluxx/window-configuration (current-window-configuration))
    (delete-other-windows)))



#+end_src
** Kill-buffer
Kill every buffer that is not the dashboard
#+begin_src emacs-lisp
(defun kill-buffer-and-maybe-open-dashboard ()
  "Kill current buffer if it's not dashboard, and open dashboard if it was the last user buffer."
  (interactive)
  (let ((buffer (current-buffer)))
    (when (string-equal (buffer-name buffer) "*dashboard*")
      (error "Cannot kill *dashboard* buffer"))
    (when (and (not (string-equal (buffer-name buffer) "*dashboard*"))
               (= 1 (length (delq nil (mapcar (lambda (buf)
                                                (and (buffer-live-p buf)
                                                     (not (string-prefix-p " " (buffer-name buf)))))
                                              (buffer-list))))))
      (dashboard-refresh-buffer))
    (kill-buffer (current-buffer))))
#+end_src
** Wal-watcher
Setup file watcher for ~/.cache/wal/colors
#+begin_src emacs-lisp
(run-with-idle-timer
 1 nil
 (lambda ()
   (file-notify-add-watch
    "~/.cache/wal/colors"
    '(change)
    (lambda (event)
      (load-theme 'ewal-doom-one t)
      (enable-theme 'ewal-doom-one)))))
#+end_src
** Load-Org-Colors
#+begin_src emacs-lisp
(defun laluxx/load-org-wal-colors ()
  "Load colors from the wal cache and apply them to org levels."
  (interactive)
  (let* ((wal-colors (with-temp-buffer
                       (insert-file-contents "~/.cache/wal/colors")
                       (split-string (buffer-string) "\n" t)))
         (wal-colors (cdr wal-colors))) ;; remove the black color (first one)
    (dotimes (level (min 8 (length wal-colors)))
      (let ((color (nth level wal-colors)))
        (set-face-attribute (intern (format "org-level-%d" (1+ level))) nil :foreground color)))))
#+end_src

#+RESULTS:
: laluxx/load-org-wal-colors

** Doom
*** Wal
doom the wallpaper
#+begin_src emacs-lisp
;; TODO: set a specific wallpaper based on the theme,                                            [x]  set-wallpaper-to-match-doom-theme

;; (defun laluxx/doom-wal ()
;;   "Run theme-magic-from-emacs, PyWal scripts and execute PyWal scripts."
;;   (interactive)
;;   (theme-magic-from-emacs)
;;   (shell-command "pkill picom")
;;   (shell-command "python3 /home/l/xos/pywal-scripts/xmonad-dark-wal.py")    ;; Xmonad dark  theme
;;   ;; (shell-command "python3 /home/l/xos/pywal-scripts/xmonad-light-wal.py") ;; light theme
;;   (laluxx/set-wallpaper-to-match-doom-theme)
;;   (shell-command "xmonad --restart"))
;;   (shell-command "python3 /home/l/xos/pywal-scripts/nvim-wal.py")

(defun laluxx/doom-wal ()
  "Run theme-magic-from-emacs, PyWal scripts and execute PyWal scripts."
  (interactive)

  ;; Apply the theme settings from Emacs to the rest of the system
  (theme-magic-from-emacs)

  ;; Kill the picom process
  (shell-command "pkill picom")

  ;; Set the wallpaper to match the Doom theme
  (laluxx/set-wallpaper-to-match-doom-theme)

  ;; Check the WM name
  (let ((wm-name (string-trim (shell-command-to-string "wmctrl -m | awk 'NR==1 {print $2}'"))))
    (cond
     ;; For LG3D, run the xmonad-dark-wal.py and restart xmonad
     ((string-equal wm-name "LG3D")
      (shell-command "python3 /home/l/xos/pywal-scripts/xmonad-dark-wal.py")
      (shell-command "xmonad --restart"))
     ;; For dwm, simulate the super+F5 keypress
     ((string-equal wm-name "dwm")
      (shell-command "xdotool key super+F5"))))

  ;; Run the external Python script for nvim theme settings
  (shell-command "python3 /home/l/xos/pywal-scripts/nvim-wal.py")

  ;; Refresh the powerline
  (powerline-reset))


(map! :leader
      "dw" #'laluxx/doom-wal)

#+end_src
*** Send
trying to send colors without applying the ewal-doom-one theme
#+begin_src emacs-lisp
(defun laluxx/doom-wal-send ()
  "Run theme-magic-from-emacs, PyWal scripts, then quickly revert the theme to the original."
  (interactive)

  ;; Store the current theme
  (setq current-theme (car doom-enabled-themes))

  ;; Temporarily switch to ewal-doom-one to get colors
  (doom/load-theme 'ewal-doom-one t t)

  ;; Apply the theme settings from Emacs to the rest of the system
  (theme-magic-from-emacs)

  ;; Kill the picom process
  (shell-command "pkill picom")

  ;; Set the wallpaper to match the Doom theme
  (laluxx/set-wallpaper-to-match-doom-theme)

  ;; Check the WM name
  (let ((wm-name (string-trim (shell-command-to-string "wmctrl -m | awk 'NR==1 {print $2}'"))))
    (cond
     ;; For LG3D, run the xmonad-dark-wal.py and restart xmonad
     ((string-equal wm-name "LG3D")
      (shell-command "python3 /home/l/xos/pywal-scripts/xmonad-dark-wal.py")
      (shell-command "xmonad --restart"))
     ;; For dwm, simulate the super+F5 keypress
     ((string-equal wm-name "dwm")
      (shell-command "xdotool key super+F5"))))

  ;; Run the external Python script for nvim theme settings
  (shell-command "python3 /home/l/xos/pywal-scripts/nvim-wal.py")

  ;; Refresh the powerline
  (spaceline-compile)

  ;; Revert to the original theme immediately after sending colors
  (doom/load-theme current-theme t t)
  ;; The clearing of caches may not be needed, as we're reloading the theme immediately.
  ;; But you can keep this part if you experience any issues.
  (setq doom-themes--colors nil
        doom-themes--min-colors nil
        doom-themes--base-faces nil
        doom-themes--extra-faces nil)
)


#+end_src
** Doom-wal-light
#+begin_src emacs-lisp
;; TODO: set a specific wallpaper based on the theme,                                            [x]  set-wallpaper-to-match-doom-theme
;; TODO: org bullets should use those colors too,                                                []
;; TODO: make a version of this function that let you consuel a theme and do everything,         []
;; TODO: make this function send a signal to xmonad to set all workspaces to "threecol"          []

(defun laluxx/doom-wal-light ()
  "Run theme-magic-from-emacs, PyWal scripts and execute PyWal scripts."
  (interactive)
  (theme-magic-from-emacs)
  (shell-command "pkill picom")
  (shell-command "python3 /home/l/xos/pywal-scripts/xmonad-light-wal.py") ;; xmonad light theme
  (laluxx/set-wallpaper-to-match-doom-theme)
  (shell-command "xmonad --restart"))
  (shell-command "python3 /home/l/xos/pywal-scripts/nvim-wal.py")
#+end_src
** set-wallpaper-to-match-doom-theme
will look into =~/xos/wallpaper/doom= for wallpapers called like doom-one.png or ef-summer.jpg
#+begin_src emacs-lisp
(defun laluxx/set-wallpaper-to-match-doom-theme ()
  "Set the desktop wallpaper based on the current Doom Emacs theme."

  (interactive)

  (let* ((theme-name (symbol-name doom-theme))
         (wallpaper-base-path "~/xos/wallpapers/doom/")
         (png-wallpaper (concat wallpaper-base-path theme-name ".png"))
         (jpg-wallpaper (concat wallpaper-base-path theme-name ".jpg"))
         (wallpaper nil))

    ;; Check for PNG and then JPG wallpaper
    (if (file-exists-p png-wallpaper)
        (setq wallpaper png-wallpaper)
      (if (file-exists-p jpg-wallpaper)
          (setq wallpaper jpg-wallpaper)))

    ;; If a matching wallpaper was found, set it using feh
    (if wallpaper
        (shell-command (concat "feh --bg-scale " wallpaper))
      (message "No matching wallpaper found for theme '%s'" theme-name))))
#+end_src

*** Org
#+begin_src emacs-lisp
(defun org-insert-header-tags ()
  "Insert personalized header tags at the beginning of the current Org file."
  (interactive)
  (goto-char (point-min)) ; Move to the beginning of the buffer
  (insert "#+TITLE: \n") ; Insert TITLE tag
  (insert "#+AUTHOR: laluxx\n") ; Insert AUTHOR tag with your desired value
  (insert "#+DESCRIPTION: \n") ; Insert DESCRIPTION tag
  (insert "#+STARTUP: showeverything\n") ; Insert STARTUP tag
  (insert "#+PROPERTY: header-args :tangle\n") ; Insert TANGLE tag
  (insert "\n") ; Insert a newline for separation
  (message "Header tags inserted.")
  (evil-goto-first-line) ; Move cursor to the top of the buffer
  (evil-append-line 0)) ; Move cursor to the end of the line (after TITLE) and enter insert mode (Evil)
#+end_src

#+begin_src emacs-lisp
(defun org-jump-to-tangled ()
  "Jump to the tangled file corresponding to the current Org mode file."
  (interactive)
  (let ((tangled-file (org-jump-to-tangled-file-name)))
    (if tangled-file
        (find-file (expand-file-name tangled-file (file-name-directory buffer-file-name)))
      (message "Tangled file not specified in the document."))))

(defun org-jump-to-tangled-file-name ()
  "Extract the tangled file name from the Org mode file properties.
If not specified, return nil."
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward "^#\\+PROPERTY: header-args :tangle \\(.+\\)$" nil t)
      (match-string 1))))

(defun org-jump-to-tangled-split-and-zoom ()
  "Split the window vertically, jump to the tangled file corresponding to the current Org mode file in the new window, and adjust the zoom level."
  (interactive)
  (let ((tangled-file (org-jump-to-tangled-file-name)))
    (if tangled-file
        (progn
          (text-scale-set -1)  ;; Set the desired zoom level here
          (execute-kbd-macro (kbd "SPC w v"))  ;; Split window vertically
          (execute-kbd-macro (kbd "SPC o j"))) ;; Jump to tangled
      (message "Tangled file not specified in the document."))))
#+end_src

** List-hooks
#+begin_src emacs-lisp
(defun laluxx/list-hooks ()
  "List all hooks in a completing-read interface."
  (interactive)
  (let* ((hook-symbols (sort
                        (seq-filter (lambda (sym)
                                      (and (symbolp sym)
                                           (string-suffix-p "-hook" (symbol-name sym))))
                                    (append obarray nil))
                        #'string-lessp))
         (hooks (mapcar #'symbol-name hook-symbols))
         (selected-hook (completing-read "Hooks: " hooks)))
    (when selected-hook
      (describe-variable (intern selected-hook)))))
#+end_src
*** Open-dir
#+begin_src emacs-lisp
(defun open-dir (key desc dir)
  (map! :leader
        :desc desc
        key (lambda () (interactive) (dired dir))))
#+end_src

* Open-dir-keybind
open-dir defined in =FUNCTIONS=
#+begin_src emacs-lisp
(open-dir "f P" "Open dotfiles directory" "~/Desktop/pulls/dotfiles/.config/doom")
(open-dir "f t" "Open test directory" "~/Desktop/test")
(open-dir "f x" "Open xos directory" "~/xos")
(open-dir "f z" "Open dotfiles zsh directory" "~/Desktop/pulls/dotfiles/.config/zsh")
(open-dir "f c" "Open ~/.config" "~/.config")
#+end_src
* IVY
** IVY-POSFRAME
Available functions (positions) for 'ivy-posframe-display-functions-alist'
+ ivy-posframe-display-at-frame-center
+ ivy-posframe-display-at-window-center
+ ivy-posframe-display-at-frame-bottom-left
+ ivy-posframe-display-at-window-bottom-left
+ ivy-posframe-display-at-frame-bottom-window-center
+ ivy-posframe-display-at-point
+ ivy-posframe-display-at-frame-top-center

=NOTE:= If the setting for 'ivy-posframe-display' is set to 'nil' (false), anything that is set to 'ivy-display-function-fallback' will just default to their normal position in Doom Emacs (usually a bottom split).  However, if this is set to 't' (true), then the fallback position will be centered in the window.

#+BEGIN_SRC emacs-lisp
(setq ivy-posframe-display-functions-alist
      '((swiper                     . ivy-posframe-display-at-point)
        (complete-symbol            . ivy-posframe-display-at-point)
        ;; (counsel-M-x                . ivy-display-function-fallback)
        (counsel-esh-history        . ivy-posframe-display-at-window-center)
        (counsel-describe-function  . ivy-display-function-fallback)
        (counsel-describe-variable  . ivy-display-function-fallback)
        (counsel-find-file          . ivy-display-function-fallback)
        (counsel-recentf            . ivy-display-function-fallback)
        (counsel-register           . ivy-posframe-display-at-frame-bottom-window-center)
        (dmenu                      . ivy-posframe-display-at-frame-top-center)
        (nil                        . ivy-posframe-display))
      ivy-posframe-height-alist
      '((swiper . 20)
        (dmenu . 20)
        (t . 10)))
(ivy-posframe-mode 1) ; 1 enables posframe-mode, 0 disables it.
#+END_SRC

** IVY KEYBINDINGS
By default, Doom Emacs does not use 'SPC v', so the format I use for these bindings is 'SPC v' plus 'key'.

#+BEGIN_SRC emacs-lisp
(map! :leader
      (:prefix ("v" . "Ivy")
       :desc "Ivy push view" "v p" #'ivy-push-view
       :desc "Ivy switch view" "v s" #'ivy-switch-view))
#+END_SRC
* EVIL MODE
** INSERT
noob mode
#+begin_src emacs-lisp
(after! evil
  (define-key evil-insert-state-map (kbd "C-v") 'yank)
  (define-key evil-insert-state-map (kbd "C-s") 'save-buffer)
  (define-key evil-insert-state-map (kbd "C-c") 'kill-ring-save)
  (define-key evil-insert-state-map (kbd "C-x") 'kill-region)
  (define-key evil-insert-state-map (kbd "C-z") 'undo)
  (define-key evil-insert-state-map (kbd "C-y") 'redo))
#+end_src
* DIRED
** Keybinds
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("d" . "dired")
       :desc "Open dired" "d" #'dired
       :desc "Dired jump to current" "j" #'dired-jump)
       ;; :desc "Dired split jump" "J" #'dired-jump)
      (:after dired
       (:map dired-mode-map
        :desc "Peep-dired image previews" "d p" #'peep-dired ;; HALF WORKING
        :desc "Dired view file"           "d v" #'dired-view-file)))
#+end_src
** Condifuration
#+begin_src emacs-lisp
(evil-define-key 'normal dired-mode-map
  (kbd "<escape>") 'delete-frame
  (kbd "M-RET") 'dired-display-file
  (kbd "h") 'dired-up-directory
  (kbd "l") 'dired-open-file ; use dired-find-file instead of dired-open.
  (kbd "m") 'dired-mark
  (kbd "t") 'dired-toggle-marks
  (kbd "u") 'dired-unmark
  (kbd "C") 'dired-do-copy
  (kbd "J") 'dired-goto-file
  (kbd "M") 'dired-do-chmod
  (kbd "O") 'dired-do-chown
  (kbd "P") 'dired-do-print
  (kbd "R") 'dired-do-rename
  (kbd "r") 'laluxx/dired-run-or-find
  (kbd "T") 'dired-do-touch
  (kbd "Y") 'dired-copy-filenamecopy-filename-as-kill ; copies filename to kill ring.
  (kbd "Z") 'dired-do-compress
  ;; (kbd "D") 'dired-do-delete
  (kbd "D") 'dired-create-directory
  (kbd "-") 'dired-do-kill-lines
  (kbd "% l") 'dired-downcase
  (kbd "% m") 'dired-mark-files-regexp
  (kbd "% u") 'dired-upcase
  (kbd "* %") 'dired-mark-files-regexp
  (kbd "* .") 'dired-mark-extension
  (kbd "* /") 'dired-mark-directories
  (kbd "; d") 'epa-dired-do-decrypt
  (kbd "; e") 'epa-dired-do-encrypt)
;; Get file icons in dired
(add-hook 'dired-mode-hook 'all-the-icons-dired-mode)
;; With dired-open plugin, you can launch external programs for certain extensions
;; For example, I set all .png files to open in 'sxiv' and all .mp4 files to open in 'mpv'
(setq dired-open-extensions '(("gif" . "sxiv")
                              ("jpg" . "sxiv")
                              ("png" . "sxiv")
                              ("mkv" . "mpv")
                              ("mp4" . "mpv")))
#+end_src
** Custom faces
#+begin_src emacs-lisp
;; (custom-set-faces
;;   '(dired-header ((t (:family "JetBrains Mono NF ExtraBold" :height 120))))
;;   '(dired-directory ((t (:family "JetBrains Mono NF ExtraBold" :height 120)))))
#+end_src
** Run
#+begin_src emacs-lisp
(setq async-shell-command-buffer 'rename-buffer)

(defun laluxx/dired-run-or-find ()
  "In Dired, run a script if it's a script, enter directory if it's a directory, or open the file otherwise."
  (interactive)
  (let ((file (dired-get-file-for-visit)))
    (cond
     ((file-directory-p file) (dired-find-file)) ; If it's a directory, recurse into it
     ((and (file-exists-p file) (file-executable-p file)) ; If it's an executable file, run it and also open it
      (find-file file)
      (async-shell-command (concat "./" file " > /dev/null 2>&1 &")))
     ((and (file-exists-p file) (string-match-p "\\.py\\'" file)) ; If it's a Python script, run it and also open it
      (find-file file)
      (async-shell-command (concat "python " file " > /dev/null 2>&1 &")))
     ((file-exists-p file) (find-file file)) ; If it's another type of file, just open it
     (t (message "No file on this line")))))


#+end_src
** Keybindings Within Dired With Peep-Dired-Mode Enabled
If peep-dired is enabled, you will get image previews as you go up/down with 'j' and 'k'
#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal peep-dired-mode-map
  (kbd "j") 'peep-dired-next-file
  (kbd "k") 'peep-dired-prev-file)
(add-hook 'peep-dired-hook 'evil-normalize-keymaps)
#+END_SRC
* SPACELINE
** Conf
#+begin_src emacs-lisp
(use-package spaceline-config
  :ensure spaceline
  :config
  (setq spaceline-buffer-encoding-abbrev-p nil
        spaceline-line-column-p nil
        spaceline-line-p nil
        spaceline-highlight-face-func 'spaceline-highlight-face-evil-state
        powerline-default-separator 'wave)

  (spaceline-define-segment evil-state
    "The current evil state.  Requires `evil-mode' to be enabled."
    (when (bound-and-true-p evil-local-mode)
      (s-trim (evil-state-property evil-state :tag t))))

  (spaceline-define-segment buffer-modified
    "Replace the `buffer-modified' segment with an exclamation point for
    modified buffers and an asterisk for read-only buffers."
    (cond (buffer-read-only "*")
          ((buffer-modified-p) "!")))

  (setq spaceline-left
        '((evil-state :face highlight-face)
          (buffer-modified :face error-face)
          anzu
          auto-compile
          ((buffer-id buffer-size) :separator " | ")
          major-mode
          ((flycheck-error flycheck-warning flycheck-info)
           :when active)
          (version-control :when active)
          (org-pomodoro :when active)
          (org-clock :when active)))

  (setq spaceline-right
        '((global :when active)
          buffer-position
          hud))

  (spaceline-spacemacs-theme))
#+end_src
** toggle-modeline
#+begin_src emacs-lisp
(defvar my-modeline-state 'spaceline)

(defun laluxx/toggle-modeline-local ()
  "Toggle between spaceline and no modeline for the current buffer."
  (interactive)
  (if (eq my-modeline-state 'spaceline)
      (progn
        (setq my-modeline-state 'none)
        (hide-mode-line-mode 1))
    (progn
      (hide-mode-line-mode -1)
      (setq my-modeline-state 'spaceline)
      (spaceline-spacemacs-theme))))

(defun laluxx/toggle-modeline-global ()
  "Toggle between spaceline and no modeline globally."
  (interactive)
  (if (eq my-modeline-state 'spaceline)
      (progn
        (setq my-modeline-state 'none)
        (global-hide-mode-line-mode 1))
    (progn
      (global-hide-mode-line-mode -1)
      (setq my-modeline-state 'spaceline)
      (spaceline-spacemacs-theme))))

(map! :leader
      (:prefix ("t" . "toggle")
       "m" #'laluxx/toggle-modeline-local
       "M" #'laluxx/toggle-modeline-global))


#+end_src

* RAINBOW MODE
turned on all the time, regardless of the mode.
The following creates a global minor mode for rainbow-mode and enables it (exception: org-agenda-mode since rainbow-mode destroys all highlighting in org-agenda).
#+begin_src emacs-lisp
(define-globalized-minor-mode global-rainbow-mode rainbow-mode
  (lambda ()
    (when (not (memq major-mode
                (list 'org-agenda-mode)))
     (rainbow-mode 1))))
(global-rainbow-mode 1 )
#+end_src
* Emacs-run
** Run-launcher
#+begin_src emacs-lisp
(defun emacs-run-launcher ()
  "Create and select a frame called emacs-run-launcher which consists only of a minibuffer and has specific dimensions. Runs app-launcher-run-app on that frame, which is an emacs command that prompts you to select an app and open it in a dmenu like behaviour. Delete the frame after that command has exited"
  (interactive)
  (with-selected-frame
    (make-frame '((name . "emacs-run-launcher")
                  (minibuffer . only)
                  (fullscreen . 0) ; no fullscreen
                  (undecorated . t) ; remove title bar
                  ;;(auto-raise . t) ; focus on this frame
                  ;;(tool-bar-lines . 0)
                  ;;(menu-bar-lines . 0)
                  (internal-border-width . 10)
                  (width . 80)
                  (height . 11)))
                  (unwind-protect
                    (app-launcher-run-app)
                    (delete-frame))))
#+end_src
** wal-set
*** Default
#+begin_src emacs-lisp
(defun emacs-run-wal-set ()
  "Create and select a frame called emacs-run-launcher which consists only of a minibuffer and has specific dimensions. Runs app-launcher-run-app on that frame, which is an emacs command that prompts you to select an app and open it in a dmenu like behaviour. Delete the frame after that command has exited"
  (interactive)
  (with-selected-frame
    (make-frame '((name . "emacs-run-wal-set")
                  (minibuffer . only)
                  (fullscreen . 0) ; no fullscreen
                  (undecorated . t) ; remove title bar
                  ;;(auto-raise . t) ; focus on this frame
                  ;;(tool-bar-lines . 0)
                  ;;(menu-bar-lines . 0)
                  (internal-border-width . 10)
                  (width . 80)
                  (height . 11)))
                  (unwind-protect
                    (laluxx/wal-set)
                    (delete-frame))))
#+end_src
*** Animated
#+begin_src emacs-lisp
(defun emacs-run-wal-set-animated ()
  "Create and select a frame called emacs-run-launcher which consists only of a minibuffer and has specific dimensions. Runs app-launcher-run-app on that frame, which is an emacs command that prompts you to select an app and open it in a dmenu like behaviour. Delete the frame after that command has exited"
  (interactive)
  (with-selected-frame
    (make-frame '((name . "emacs-run-wal-set-animated")
                  (minibuffer . only)
                  (fullscreen . 0) ; no fullscreen
                  (undecorated . t) ; remove title bar
                  ;;(auto-raise . t) ; focus on this frame
                  ;;(tool-bar-lines . 0)
                  ;;(menu-bar-lines . 0)
                  (internal-border-width . 10)
                  (width . 80)
                  (height . 11)))
                  (unwind-protect
                    (laluxx/wal-set-animated)
                    (delete-frame))))

#+end_src
*** Solid
#+begin_src emacs-lisp
(defun emacs-run-wal-set-solid ()
  "Create and select a frame called emacs-run-launcher which consists only of a minibuffer and has specific dimensions. Runs app-launcher-run-app on that frame, which is an emacs command that prompts you to select an app and open it in a dmenu like behaviour. Delete the frame after that command has exited"
  (interactive)
  (with-selected-frame
    (make-frame '((name . "emacs-run-wal-set-solid")
                  (minibuffer . only)
                  (fullscreen . 0) ; no fullscreen
                  (undecorated . t) ; remove title bar
                  ;;(auto-raise . t) ; focus on this frame
                  ;;(tool-bar-lines . 0)
                  ;;(menu-bar-lines . 0)
                  (internal-border-width . 10)
                  (width . 80)
                  (height . 11)))
                  (unwind-protect
                    (laluxx/wal-set-solid)
                    (delete-frame))))
#+end_src
*** favourite
#+begin_src emacs-lisp
(defun emacs-run-wal-set-favourite ()
  "Create and select a frame called emacs-run-launcher which consists only of a minibuffer and has specific dimensions. Runs app-launcher-run-app on that frame, which is an emacs command that prompts you to select an app and open it in a dmenu like behaviour. Delete the frame after that command has exited"
  (interactive)
  (with-selected-frame
    (make-frame '((name . "emacs-run-wal-set-favourite")
                  (minibuffer . only)
                  (fullscreen . 0) ; no fullscreen
                  (undecorated . t) ; remove title bar
                  ;;(auto-raise . t) ; focus on this frame
                  ;;(tool-bar-lines . 0)
                  ;;(menu-bar-lines . 0)
                  (internal-border-width . 10)
                  (width . 80)
                  (height . 11)))
                  (unwind-protect
                    (laluxx/wal-set-favourite)
                    (delete-frame))))
#+end_src
*** Set-wallpaper
#+begin_src emacs-lisp
(defun emacs-run-set-wallpaper ()
  "Create and select a frame called emacs-run-launcher which consists only of a minibuffer and has specific dimensions. Runs app-launcher-run-app on that frame, which is an emacs command that prompts you to select an app and open it in a dmenu like behaviour. Delete the frame after that command has exited"
  (interactive)
  (with-selected-frame
    (make-frame '((name . "emacs-run-set-wallpaper")
                  (minibuffer . only)
                  (fullscreen . 0) ; no fullscreen
                  (undecorated . t) ; remove title bar
                  ;;(auto-raise . t) ; focus on this frame
                  ;;(tool-bar-lines . 0)
                  ;;(menu-bar-lines . 0)
                  (internal-border-width . 10)
                  (width . 80)
                  (height . 11)))
                  (unwind-protect
                    (laluxx/set-wallpaper)
                    (delete-frame))))
#+end_src
*** Set-animated-wallpaper
#+begin_src emacs-lisp
(defun emacs-run-set-animated-wallpaper ()
  "Create and select a frame called emacs-run-launcher which consists only of a minibuffer and has specific dimensions. Runs app-launcher-run-app on that frame, which is an emacs command that prompts you to select an app and open it in a dmenu like behaviour. Delete the frame after that command has exited"
  (interactive)
  (with-selected-frame
    (make-frame '((name . "emacs-run-set-animated-wallpaper")
                  (minibuffer . only)
                  (fullscreen . 0) ; no fullscreen
                  (undecorated . t) ; remove title bar
                  ;;(auto-raise . t) ; focus on this frame
                  ;;(tool-bar-lines . 0)
                  ;;(menu-bar-lines . 0)
                  (internal-border-width . 10)
                  (width . 80)
                  (height . 11)))
                  (unwind-protect
                    (laluxx/set-animated-wallpaper)
                    (delete-frame))))
#+end_src
** M-X
#+begin_src emacs-lisp
(defun emacs-run-M-x ()
  "Create a new frame and prompt for an M-x command in it."
  (interactive)
  (with-selected-frame
      (make-frame '((name . "emacs-run-M-x")
                    (minibuffer . only)
                    (fullscreen . 0)
                    (undecorated . t)
                    (internal-border-width . 10)
                    (width . 80)
                    (height . 11)))
    (unwind-protect
        (call-interactively 'execute-extended-command)
      (delete-frame))))
#+end_src
** Info
Open info inside xmonad  DONE:
- remember last manual manual [x]
- Toggle [x]
- ewal break this []
#+begin_src emacs-lisp
(defvar emacs-run-info-frame nil)

(defun emacs-run-info ()
  "Create a new frame and run 'info' in it."
  (interactive)
  (if (and emacs-run-info-frame (frame-live-p emacs-run-info-frame))
      ;; If the frame exists, delete it.
      (progn
        (delete-frame emacs-run-info-frame)
        (setq emacs-run-info-frame nil))
    ;; Else, create a new frame.
    (let* ((new-frame (make-frame '((name . "emacs-run-info")
                                    (minibuffer . t)
                                    (fullscreen . 0)
                                    (undecorated . t)
                                    (internal-border-width . 10)
                                    (width . 80)
                                    (height . 11)))))
      (setq emacs-run-info-frame new-frame)
      (select-frame-set-input-focus new-frame)
      (with-selected-window (frame-selected-window new-frame)
        (switch-to-buffer (save-window-excursion
                            (info)
                            (current-buffer)))
        (delete-other-windows)
        (define-key Info-mode-map (kbd "<escape>") 'delete-frame)))))



#+end_src
** Which-key
#+begin_src emacs-lisp
;; (defun emacs-run-which-key ()
;;   "Create a new frame and prompt for a which-key command in it."
;;   (interactive)
;;   (let ((new-frame (make-frame '((name . "emacs-run-which-key")
;;                                  (minibuffer . only)
;;                                  (fullscreen . 0)
;;                                  (undecorated . t)
;;                                  (internal-border-width . 10)
;;                                  (width . 80)
;;                                  (height . 11)))))
;;     (with-selected-frame new-frame
;;       (which-key-mode 1)
;;       (call-interactively 'which-key-show-top-level))))
#+end_src
** Dired
TODO
- esc don't close the frame [x]
- hide modeline [x]

#+begin_src emacs-lisp
(defun hide-mode-line-in-dired-frame (frame)
  "Hide the mode line in the 'emacs-run-dired' frame."
  (when (string-equal (frame-parameter frame 'name) "emacs-run-dired")
    (with-selected-frame frame
      (setq-default mode-line-format nil))))

(add-hook 'after-make-frame-functions 'hide-mode-line-in-dired-frame)

(defun emacs-run-dired ()
  "Create a new frame and open dired in it."
  (interactive)
  (let* ((original-frame (selected-frame))
         (new-frame (make-frame '((name . "emacs-run-dired")
                                  (width . 80)
                                  (height . 24)
                                  (minibuffer . t)
                                  (undecorated . t)
                                  (internal-border-width . 10)
                                  (fullscreen . 0)))))
    (select-frame-set-input-focus new-frame)
    (with-selected-window (frame-selected-window new-frame)
      (dired "~"))  ;; opens dired in your home directory, change "~" to any directory you prefer
    (define-key dired-mode-map (kbd "<escape>") 'delete-frame)
    (select-frame-set-input-focus original-frame)))
#+end_src
** Clone-client-frame
#+begin_src emacs-lisp
(defun hide-mode-line-in-frame (frame)
  "Hide the mode line in the specified frames."
  (when (string-match-p "^emacs-run-clone-client-frame" (frame-parameter frame 'name))
    (with-selected-frame frame
      (setq mode-line-format nil))))

(add-hook 'after-make-frame-functions 'hide-mode-line-in-frame)

(defun emacs-run-clone-client-frame ()
  "Create a new frame and activate which-key-mode in it."
  (interactive)
  (let ((new-frame (make-frame '((name . "emacs-run-clone-client-frame")
                                 (minibuffer . nil)
                                 (fullscreen . 0)
                                 (undecorated . t)
                                 (internal-border-width . 10)
                                 (width . 80)
                                 (height . 11)))))
    (with-selected-frame new-frame
      (which-key-mode 1)
      (minibuffer-keyboard-quit))))

(defun emacs-run-clone-client-frame-bottom ()
  "Create a new frame and activate which-key-mode in it."
  (interactive)
  (let ((new-frame (make-frame '((name . "emacs-run-clone-client-frame-bottom")
                                 (minibuffer . nil)
                                 (fullscreen . 0)
                                 (undecorated . t)
                                 (internal-border-width . 10)
                                 (width . 80)
                                 (height . 11)))))
    (with-selected-frame new-frame
      (which-key-mode 1)
      (minibuffer-keyboard-quit))))


#+end_src
*** Dmenu
#+begin_src emacs-lisp
(defun emacs-run-dmenu ()
  "Create a new frame and run dmenu in it."
  (interactive)
  (with-selected-frame
      (make-frame '((name . "emacs-run-dmenu")
                    (minibuffer . only)
                    (fullscreen . 0)
                    (undecorated . t)
                    (internal-border-width . 10)
                    (width . 80)
                    (height . 11)))
    (unwind-protect
        (call-interactively 'dmenu)
      (delete-frame))))


#+end_src
* Config
** Org
#+begin_src emacs-lisp
(defun laluxx/insert-auto-tangle-tag ()
  "Insert auto-tangle tag in a literate config."
  (interactive)
  (evil-org-open-below 1)
  (insert "#+auto_tangle: t ")
  (evil-org-open-below 1)
  (insert "#+PROPERTY: header-args :tangle ")
  (evil-force-normal-state))

(map! :leader
      :desc "Insert auto_tangle tag" "i a" #'laluxx/insert-auto-tangle-tag)
#+end_src
** Info-colors
#+begin_src emacs-lisp
(add-hook 'Info-selection-hook 'info-colors-fontify-node)
#+end_src
** Ibuffer
#+begin_src emacs-lisp
(defun laluxx/ibuffer-only ()
  "Open ibuffer and delete other windows."
  (interactive)
  (ibuffer)
  (delete-other-windows))


(map! :leader
      :desc "Open ibuffer only"
      "b i" #'laluxx/ibuffer-only)


#+end_src
** Neotree
#+begin_src emacs-lisp
(with-eval-after-load 'neotree
  (define-key neotree-mode-map (kbd "M-h") 'neotree-toggle))
#+end_src
** Edwina
#+begin_src emacs-lisp
(use-package! edwina
  :config
  ;; Your config here...
  (setq display-buffer-base-action '(display-buffer-below-selected))
  (edwina-setup-dwm-keys)
  (edwina-mode 1))
#+end_src
** Evil
#+begin_src emacs-lisp
;; (after! evil
;;   (map! :after evil
;;         :map evil-insert-state-map
;;         "C-h" #'evil-backward-char
;;         "C-j" #'evil-next-line
;;         "C-k" #'evil-previous-line
;;         "C-l" #'evil-forward-char))
#+end_src
** org-auto-tangle
=org-auto-tangle= allows you to add the option =#+auto_tangle: t= in your Org file so that it automatically tangles when you save the document.
#+begin_src emacs-lisp
(use-package! org-auto-tangle
  :defer t
  :hook (org-mode . org-auto-tangle-mode)
  :config
  (setq org-auto-tangle-default t))

(defun laluxx/insert-auto-tangle-tag ()
  "Insert auto-tangle tag in a literate config."
  (interactive)
  (evil-org-open-below 1)
  (insert "#+auto_tangle: t ")
  (evil-force-normal-state))

(map! :leader
      :desc "Insert auto_tangle tag" "i a" #'laluxx/insert-auto-tangle-tag)
#+end_src
** Centaur-tabs
#+begin_src emacs-lisp
(after! centaur-tabs
  (setq centaur-tabs-style "rounded"
        centaur-tabs-height 32
        centaur-tabs-set-icons t
        centaur-tabs-set-bar 'under
        x-underline-at-descent-line t
        centaur-tabs-set-modified-marker t
        centaur-tabs-show-navigation-buttons t
        centaur-tabs-show-new-tab-button t
        centaur-tabs-left-edge-margin nil
        centaur-tabs-cycle-scope 'tabs)
  (centaur-tabs-mode t)
  (centaur-tabs-headline-match)
  (setq centaur-tabs-adjust-buffer-order t))



(defun my/centaur-tabs-mode-condition ()
  (if (or (> (count-windows) 1)
          (derived-mode-p 'dashboard-mode 'vterm-mode 'dired-mode))
      (centaur-tabs-local-mode)  ;; disable if more than one window or in one of the listed modes
    (centaur-tabs-local-mode -1)))  ;; enable otherwise


;; Run the function after every buffer list update
(add-hook 'buffer-list-update-hook 'my/centaur-tabs-mode-condition)


#+end_src
** Vterm
#+begin_src emacs-lisp
;; (add-hook 'vterm-mode-hook
;;           (lambda ()
;;             (define-key vterm-mode-map (kbd "C-j") 'other-window)
;;             (define-key vterm-mode-map (kbd "C-k")
;;               (lambda ()
;;                 (interactive)
;;                 (other-window -1)))
;;             (define-key vterm-mode-map (kbd "C-h") 'neotree-or-enlarge-window-left)
;;             (define-key vterm-mode-map (kbd "C-l") 're-builder-or-enlarge-window-right)
;;             (define-key vterm-mode-map (kbd "C-M-j") 'rotate-window)
;;             (define-key vterm-mode-map (kbd "C-M-k")
;;               (lambda ()
;;                 (interactive)
;;                 (dotimes (_ (- (length (window-list)) 1))
;;                   (rotate-window))))
;;             (evil-define-key 'normal vterm-mode-map (kbd "q") 'delete-window)))

(add-hook 'vterm-mode-hook
          (lambda ()
            (evil-define-key 'insert vterm-mode-map (kbd "C-j") 'other-window)
            (evil-define-key 'insert vterm-mode-map (kbd "C-k")
              (lambda ()
                (interactive)
                (other-window -1)))
            (evil-define-key 'insert vterm-mode-map (kbd "C-h") 'neotree-or-enlarge-window-left)
            (evil-define-key 'insert vterm-mode-map (kbd "C-l") 're-builder-or-enlarge-window-right)
            (evil-define-key 'insert vterm-mode-map (kbd "C-M-j") 'rotate-window)
            (evil-define-key 'insert vterm-mode-map (kbd "C-M-k")
              (lambda ()
                (interactive)
                (dotimes (_ (- (length (window-list)) 1))
                  (rotate-window))))
            (evil-define-key 'normal vterm-mode-map (kbd "q") 'delete-window)))



#+end_src
** Magit
#+begin_src emacs-lisp
;; (with-eval-after-load 'magit
;;   (define-key magit-mode-map (kbd "C-j") #'other-window)
;;   (define-key magit-mode-map (kbd "C-k") (lambda () (interactive) (other-window -1)))
;;   (define-key magit-mode-map (kbd "M-j") #'magit-section-forward)
;;   (define-key magit-mode-map (kbd "M-k") #'magit-section-backward))

(after! magit
  (define-key magit-mode-map (kbd "C-j") #'other-window)
  (define-key magit-mode-map (kbd "C-k") (lambda () (interactive) (other-window -1)))
  (define-key magit-mode-map (kbd "M-j") #'magit-section-forward)
  (define-key magit-mode-map (kbd "M-k") #'magit-section-backward))


#+end_src
** Neotree
#+begin_src emacs-lisp
(use-package! neotree
  :commands (neotree-show neotree-hide neotree-dir neotree-find)
  :init
  ;; Set the NeoTree theme to icons, provided by all-the-icons
  (setq neo-theme (if (display-graphic-p) 'icons 'arrow))

  ;; Enable line numbers
  (setq neo-show-line-number t)

  ;; Use the custom version of the text-scale function
  (setq neo-buffer--show-file 'neo-buffer--show-file-custom)

  ;; Make NeoTree resizable
  (setq neo-window-fixed-size nil)

  ;; Set the root directory automatically
  (setq neo-smart-open t)

  ;; Allow to use 'q' to close the NeoTree buffer
  (setq neo-keymap-style 'concise)

  ;; Hide special files
  (setq neo-hidden-files (quote (".DS_Store" ".git" ".svn" ".cache"))))

;; Keybinding for NeoTree
(map! :leader
      :desc "Toggle neotree"
      "t n" #'neotree-toggle)



(after! neotree
  (map! :map neotree-mode-map
        :n "C-j" #'my-switch-buffer-forward-or-other-window
        :n "C-k" #'my-switch-buffer-backward-or-other-window
        :n "C-h" #'neotree-hide))
#+end_src

** Ewal
*** Default
#+begin_src emacs-lisp
(use-package! ewal
  :init
  (setq ewal-use-built-in-always-p nil
        ewal-use-built-in-on-failure-p t
        ewal-built-in-palette "sexy-material"))
#+end_src
*** Ewal-Doom-Theme
this will set the theme
#+begin_src emacs-lisp
(use-package! ewal-doom-themes
  :init
  ;; If you've set ewal-use-built-in-always-p to nil in ewal configuration
  ;; This might be unnecessary, but doesn't hurt to ensure.
  (setq ewal-use-built-in-always-p nil
        ewal-use-built-in-on-failure-p t
        ewal-built-in-palette "sexy-material")
  :config
  (load-theme 'ewal-doom-one t)
  (enable-theme 'ewal-doom-one))
#+end_src

** Emojis
Emojify is an Emacs extension to display emojis. It can display github style emojis like :smile: or plain ascii ones like :).

#+begin_src emacs-lisp
(use-package emojify
  :hook (after-init . global-emojify-mode))
#+end_src
* Enable
#+begin_src emacs-lisp
;; (desktop-save-mode 1)
#+end_src
* Images
#+begin_src emacs-lisp
;; (global-set-key [double-mouse-1] 'my-open-image-at-point-in-new-buffer)

;; (defun my-open-image-at-point-in-new-buffer (event)
;;   "Open the image at point in a new buffer."
;;   (interactive "e")
;;   (let* ((window (posn-window (event-end event)))
;;          (buffer (window-buffer window))
;;          (pos (posn-point (event-end event)))
;;          (file (with-current-buffer buffer
;;                  (get-text-property pos 'display))))
;;     (when file
;;       (let ((buffer (generate-new-buffer "image-buffer")))
;;         (switch-to-buffer buffer)
;;         (insert-file-contents (car file))
;;         (image-mode)))))

;; (global-set-key [double-mouse-1] 'my-open-image-at-point-in-new-buffer)


(require 'ffap)

(defun doom/open-file-at-point-in-new-buffer (event)
  "Open the file under the mouse cursor in a new buffer."
  (interactive "e")
  (let* ((window (posn-window (event-end event)))
         (buffer (window-buffer window))
         (pos (posn-point (event-end event)))
         (file (with-current-buffer buffer
                 (ffap-file-at-point))))
    (when file
      (let ((buf (find-file-noselect file)))
        (with-current-buffer buf
          (when (member (file-name-extension file)
                        '("jpg" "jpeg" "png" "gif" "bmp"))
            (image-mode)))
        (switch-to-buffer-other-window buf)))))

(global-set-key [double-mouse-1] #'doom/open-file-at-point-in-new-buffer)
#+end_src
