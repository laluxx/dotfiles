#+title: .zshrc
#+PROPERTY: header-args :tangle .zshrc
#+auto_tangle: t

* TODO
evil keybinds to split panes (maybe inside kitty conf)
**  easy
kyeinind to fzf aur packages
* Neofetch
run neofetch only in the first terminal
#+begin_src shell
if [ -z "$NEOFETCH_RUN_ONCE" ] && [ $(pgrep -cx kitty) -eq 1 ] ; then
    neofetch
fi
#+end_src
* PATH
#+begin_src shell
function path() {
  local dir_list=$(echo $PATH | sed "s/:/\\n/g")

  # ANSI escape codes for colors and styles
  local highlight_open='\033[1;33m[\033[0m'    # Bold Yellow [
  local highlight_close='\033[1;33m]\033[0m'   # Bold Yellow ]
  local highlight_single_quote='\033[1;31m'\''\033[0m' # Bold Red '

  # Printing the list with colors
  printf "EnvPath${highlight_open}\n"
  printf "${highlight_single_quote}%s${highlight_single_quote},\n" $dir_list | sed "s|^ |/|; s|^|  |"
  printf "${highlight_close}\n"
}
#+end_src
** exports
#+begin_src shell
export PATH="$PATH:$HOME/.config/emacs/bin"
export PATH="$PATH:$HOME/.cargo/bin"

 if [[ -n $SSH_CONNECTION ]]; then
   export EDITOR='nvim'
 else
   export EDITOR='nvim'
 fi
#+end_src
*** rofi
#+begin_src shell
export ROFI_THEME="/home/l/.cache/wal/colors-rofi-dark.rasi"
#+end_src
** source
*** env-secrets
where you keep api keys
#+begin_src shell
source ~/xos/.env_secrets
#+end_src
* plugins
** syntax-highlighting
#+begin_src shell
source /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 2>/dev/null # PACMAN path
# source $HOME/.config/zsh/plug/fzf-keybindings.plugins.zsh
#+end_src
** wal
#+begin_src shell
source ~/.cache/wal/colors.sh
#+end_src
** Fallback-prompt
#+begin_src shell
#Enable colors and change fallback prompt:
autoload -U colors && colors

# PS1="%B%{$fg[red]%}[%{$fg[yellow]%}%n%{$fg[green]%}@%{$fg[blue]%}%M %{$fg[magenta]%}%~%{$fg[red]%}]%{$reset_color%}$%b "
PS1="%{$fg[red]%}[%{$fg_bold[white]%}ERROR%{$fg[red]%}]%{$reset_color%} "
#+end_src
** Fetch-plugins
#+begin_src shell
# Fetch all plugins in dir
plugins=(`echo $(ls $ZSH/plugins | sed -z 's/\n/ /g')`)
#+end_src
** Auto-tab-complete
#+begin_src shell
autoload -U compinit
zstyle ':completion:*' menu select
zmodload zsh/complist
#compinit _comp_options+=(globdots)		# Include hidden files.
#+end_src
** evil-tab
#+begin_src shell
# Use vim keys in tab complete menu:
bindkey -M menuselect 'h' vi-backward-char
bindkey -M menuselect 'k' vi-up-line-or-history
bindkey -M menuselect 'l' vi-forward-char
bindkey -M menuselect 'j' vi-down-line-or-history
bindkey -v '^?' backward-delete-char

bindkey -s '^r' 'lfcd\n'
bindkey -s '^e' 'thunar\n'
bindkey -s '^w' 'wal-set\n'
bindkey -s '^b' 'btop\n' # TODO: make it toggle
#+end_src


** xxx
#+begin_src shell
# below opens a new terminal in current dir
# case "$TERM" in (rxvt|rxvt-*|st|st-*|*xterm*|(dt|k|E)term)
#     local term_title () { print -n "\e]0;${(j: :q)@}\a" }
#     precmd () {
#       local DIR="$(print -P '[%c]')"
#       term_title "$DIR" "st"
#     }
#     preexec () {
#       local DIR="$(print -P '[%c]%#')"
#       local CMD="${(j:\n:)${(f)1}}"
#       #term_title "$DIR" "$CMD" use this if you want directory in command, below only prints program name
# 	  term_title "$CMD"
#     }
#   ;;
# esac

#Set bookmarks dir
# To add any bookmark, use command below without quotes:
# bm 'bookmarkdir' '@bookmarkname' OR bm @bookmarkname to bookmark current directory
[[ -d "$ZSHCFG/bookmarks" ]] && export CDPATH=".:$ZSHCFG/bookmarks:/" \
	&& alias jmp="cd -P"

setopt autocd
# change below theme if using oh-my-zsh
#ZSH_THEME=""
HISTSIZE=10000
SAVEHIST=10000
setopt appendhistory
#+end_src
* Cursor
#+begin_src shell
# Change cursor shape for different vi modes.
function zle-keymap-select {
  if [[ ${KEYMAP} == vicmd ]] ||
     [[ $1 = 'block' ]]; then
    echo -ne '\e[1 q'
  elif [[ ${KEYMAP} == main ]] ||
       [[ ${KEYMAP} == viins ]] ||
       [[ ${KEYMAP} = '' ]] ||
       [[ $1 = 'beam' ]]; then
    echo -ne '\e[5 q'
  fi
}
function _set_cursor() {
    if [[ $TMUX = '' ]]; then
      echo -ne $1
    else
      echo -ne "\ePtmux;\e\e$1\e\\"
    fi
}
#+end_src
* Load aliases
#+begin_src shell
# Load aliases
[ -f "$ZSHCFG/aliasrc" ] && source "$ZSHCFG/aliasrc"

# Note that in different distro or installation way below source files need to be changed, they are usually in ~/.zsh/
source "$ZSHCFG/OMZ/oh-my-zsh.sh"
source /usr/share/zsh/plugins/fast-syntax-highlighting/fast-syntax-highlighting.plugin.zsh 2>/dev/null
#+end_src
* Evil-mode
** shell
#+begin_src shell
# vi mode
bindkey -v
export KEYTIMEOUT=1
export GPG_TTY=$(tty)
if [ ! -z $BM_DIR ]; then
    cd -P $BM_DIR &&
    export BM_DIR=""
fi

# Below to change autosuggestion options
# ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE="fg=blue,bg=#292D3E,bold,underline"	# To get colored completion text
bindkey '^[[Z' autosuggest-accept   # shift tab to accept ghost text
ZSH_AUTOSUGGEST_CLEAR_WIDGETS+=(buffer-empty bracketed-paste accept-line push-line-or-edit)
ZSH_AUTOSUGGEST_STRATEGY=(history completion)
ZSH_AUTOSUGGEST_USE_ASYNC=true

export LESS_TERMCAP_mb=$(tput bold; tput setaf 39)
export LESS_TERMCAP_md=$(tput bold; tput setaf 45)
export LESS_TERMCAP_me=$(tput sgr0)


#+end_src
* MDL
Music download
#+begin_src shell
function mdl() {
    local original_dir=$(pwd)
    cd ~/Music

    for url in "$@"; do
        yt-dlp --extract-audio --audio-format mp3 -i --ignore-config  --no-part --no-warnings -w -c -R 15 --output "%(title)s.%(ext)s" "$url"
    done

    cd "$original_dir"
}
#+end_src
* SHELL
**  image-map
Define a mapping between directory names and image files
custom images based on the enviroment for a more interactive shell
#+begin_src shell
declare -A image_map=(
  ["test"]="$HOME/xos/xassets/test.png"
  # ["test"]="$HOME/xos//.png"
  # ["test"]="$HOME/xos//.jpg"
)
# rust, doom, lua, bash, c++, c, haskell, python, test
# .doom.d, emacs, doom, xwal, nix, go, debian, head
# docker, web, react, cutefish, awesome, xos, ai, deepin, welcome, default
#+end_src
* render
render images in the terminal
#+begin_src shell
function render() {
    display_info=false
    suppress_errors=false

    # Check if there are no arguments
    if [[ $# -eq 0 ]]; then
        echo "Usage: render [-i | --info] [-n | --no-errors] <image_file1> [<image_file2> ...]"
        return 1
    fi

    # Check if the first argument is -i or --info
    if [[ $1 == "-i" ]] || [[ $1 == "--info" ]]; then
        display_info=true
        shift # remove the first argument, so image_file arguments start from $1
    fi

    # Check if the first argument is -n or --no-errors
    if [[ $1 == "-n" ]] || [[ $1 == "--no-errors" ]]; then
        suppress_errors=true
        shift # remove the first argument, so image_file arguments start from $1
    fi

    # Check if 'kitty' is installed
    if ! command -v kitty > /dev/null; then
        echo "Error: 'kitty' terminal emulator is not installed or not in PATH."
        return 1
    fi

    # Loop through the image files
    for image_file in "$@"; do
        # Check if file exists
        if [[ ! -f "$image_file" ]]; then
            if ! $suppress_errors; then
                echo "Error: File '$image_file' not found."
            fi
            continue
        fi

        # Display info if flag is set
        if $display_info; then
            # Get the file size in bytes
            file_size_bytes=$(du -b "$image_file" | cut -f1)
            # Convert file size to kilobytes
            file_size_kb=$((file_size_bytes / 1024))

            # Get image dimensions
            dimensions=$(identify -format "%wx%h" "$image_file" 2>/dev/null)

            # Display file information in color in a single line
            echo -e "\033[1;36m$image_file \033[1;33m[$file_size_kb KB]\033[1;32m [$dimensions]\033[0m"
        fi

        # Render the image
        kitty +kitten icat "$image_file"
    done
}
#+end_src
* Render_pwd
#+begin_src shell
render_pwd() {
  local path_parts=("${(@s:/:)PWD}") # Split the current path into an array
  local dir=""
  for part in "${path_parts[@]}"; do
    if [[ -n "${image_map[$part]}" ]]; then
      dir="$part"
    fi
  done

  if [[ -n "$dir" ]]; then
    render -n "${image_map[$dir]}"
  else
    render -n "${image_map["default"]}"
  fi
}

render_pwd # run once
#+end_src
* DEV-TOOL
** Disassemble
#+begin_src shell
function disassemble() {
    if [ $# -eq 0 ]; then
        echo "No arguments provided. Please provide a binary file name."
        return 1
    fi

    # Disassemble the binary file using objdump
    objdump -d $1 | less
}
#+end_src
** diffrun
DIFF RUN :
monitor a directory for changes,
then automaticly run any command
#+begin_src shell
#HACK custo function and aliases should work
diffrun() {
        [ -z "$1" ] && { echo "Usage: drun <command> [file/directory]"; return 1; }
        local cmd="$1"
        local target="${2:-$PWD}"
        [ ! -e "$target" ] && { echo "Error: File or directory '$target' not found."; return 1; }
        echo "Monitoring size of '$target' for changes..."
        local prev_size=$(du -sb "$target" | awk '{print $1}')
        while sleep 1; do
            local size=$(du -sb "$target" | awk '{print $1}')
            if [ "$prev_size" -ne "$size" ]; then
            prev_size="$size"
            zsh -c $cmd
            fi
        done
    }
#+end_src
** t
#+begin_src shell
function t() {
    if [[ $# -eq 0 || $# -gt 2 ]]; then
        echo "Usage: t <filename> [<extension>]"
        return 1
    fi

    local filename="$1"
    local ext="$2"
    local template_path=~/xos/config/t/${ext}.${ext}

    # If extension is not specified, just touch the file
    if [[ -z $ext ]]; then
        touch "$filename"
    else
        if [[ ! -f $template_path ]]; then
            echo "Unsupported file type: $ext"
            return 1
        fi

        local final_filename="${filename}.${ext}"
        cp "$template_path" "$final_filename"
    fi
}
#+end_src
** web-dev
*** package-web-app
package a website in a desktop app
"package-web-app https://github.com"
#+begin_src shell
function package-web-app() {
  if [ "$#" -ne 1 ]; then
    echo "Usage: xapp <url>"
    return 1
  fi

  local url="$1"
  local app_name="$(echo ${url} | sed -E 's/.*\:\/\/([^\/]+)(.*)/\1/')"

  nativefier --name "${app_name}" "${url}" --single-instance && c
  echo "Desktop app for ${url} has been created in the current directory."
}
#+end_src
** lazytest
Usefull when you have a folder full of scripts to test.
#+begin_src shell
function lazytest() {
  # Find all Lua and Python files in the current directory
  files=()
  while IFS= read -r -d $'\0' file; do
    files+=("$file")
  done < <(find . -maxdepth 1 -type f \( -iname "*.lua" -o -iname "*.py" \) -print0)

  run_sequentially "${files[@]}"
}
#+end_src
*** run-sequentially
Dependencie of lazytest
#+begin_src shell
function run_sequentially() {
  local files=("$@")

  for file in "${files[@]}"; do
    echo "Running $file"

    case "${file##*.}" in
      lua)
        interpreter="lua"
        ;;
      py)
        interpreter="python3"
        ;;
      sh)
        interpreter="bash"
        ;;
      *)
        echo "Unsupported file extension for $file"
        continue
        ;;
    esac

    $interpreter "$file" & # Run the script in the background
    wait $!               # Wait for the background process to finish
  done
}

#+end_src
* Python
** penv
#+begin_src shell
penv() {
    case "$1" in
        -s|--source)
            if [ -n "$2" ]; then
                # Create the virtual environment
                python3 -m venv "$2"

                # Source the virtual environment
                source "$2/bin/activate"
            else
                echo "Please provide a name for the environment."
            fi
            ;;
        -d|--delete)
            if [ -n "$2" ]; then
                # Check if in the environment
                if [[ "$VIRTUAL_ENV" == *"$2"* ]]; then
                    echo "Please deactivate the environment before deleting it."
                else
                    # Ask for confirmation before deleting the virtual environment
                    echo "Are you sure you want to delete the virtual environment $2? [y/N] "
                    read confirm
                    if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
                        rm -rf "$2"
                        echo "Virtual environment $2 deleted."
                    else
                        echo "Operation canceled."
                    fi
                fi
            else
                echo "Please provide the name of the environment to delete."
            fi
            ;;
        -l|--list)
            # List all virtual environments in the current directory
            echo "Virtual environments in the current directory:"
            find . -type d -name "bin" -exec dirname {} \; 2>/dev/null
            ;;
        -q|--quit)
            # Deactivate the current environment
            if [ -n "$VIRTUAL_ENV" ]; then
                deactivate
            else
                echo "No virtual environment is active."
            fi
            ;;
        *)
            echo "Usage:"
            echo "  penv -s, --source <env_name>  # Create and source a virtual environment"
            echo "  penv -d, --delete <env_name>  # Delete a virtual environment"
            echo "  penv -l, --list               # List all virtual environments in the current directory"
            echo "  penv -q, --quit               # Deactivate the current environment"
            ;;
    esac
}
#+end_src
* BASICS
** screenshot
#+begin_src shell
function screenshot() {
  # Capture screenshot and save it to a temporary file
  local tmp_file="/tmp/screenshot.png"
  maim -s "$tmp_file"

  # Check if the screenshot was captured successfully
  if [ -f "$tmp_file" ]; then
    # Copy the screenshot to the clipboard
    xclip -selection clipboard -t image/png -i "$tmp_file"

    echo "Screenshot captured and copied to clipboard."
  else
    echo "Error capturing the screenshot."
  fi
}
#+end_src
** commons
*** Hown
#+begin_src shell
function hown() {
    for file in $@
    do
        cp $file ~/.local/bin/
    done
}
#+end_src
*** Hownfont
#+begin_src shell
function hownfont() {
    # Set target directory (you may need to adjust this depending on your system)
    target_dir=~/.fonts

    # Create the target directory if it doesn't exist
    [[ -d $target_dir ]] || mkdir -p $target_dir

    if [[ $1 == '-a' ]]; then
        # Find all font files in current directory and subdirectories
        for file in $(find . -iname '*.ttf' -o -iname '*.otf'); do
            # Copy each file to the target directory
            cp $file $target_dir
        done
    else
        # Copy the specified file to the target directory
        cp $1 $target_dir
    fi

    # Update the font cache (needed on some systems)
    fc-cache -f -v
}
#+end_src
** file-extraction
*** ex
exctract anything
#+begin_src shell
function ex()
{
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xjf $1   ;;
      *.tar.gz)    tar xzf $1   ;;
      *.tar.xz)    tar xJf $1   ;;
      *.bz2)       bunzip2 $1   ;;
      *.rar)       unrar x $1     ;;
      *.gz)        gunzip $1    ;;
      *.tar)       tar xf $1    ;;
      *.tbz2)      tar xjf $1   ;;
      *.tgz)       tar xzf $1   ;;
      *.zip)       unzip $1     ;;
      *.Z)         uncompress $1;;
      *.7z)        7z x $1      ;;
      *)           echo "'$1' cannot be extracted via ex()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}
#+end_src
** un-section
*** ungit
#+begin_src shell
function ungit() {
  rmdir .git
  echo "WHAT ARE YOU DOING ?" && sleep 1 && rm .gitignore && c
}
#+end_src
** explain
"explain" any shell function, alias, variable..
#+begin_src shell
function explain() {
  local name=$1
  local def=$(declare -f $name 2>/dev/null)

  case "$name" in
    ltree)
      local desc="Recursive directory listing with optional custom prompt"
      ;;
    lfcd)
      local desc="cd to the parent directory containing a file or directory matching the given pattern"
      ;;
    c)
      local desc="Compile and run a C program with a single command"
      ;;
    *)
      local desc=""
      ;;
  esac

  if [[ -n "$desc" ]]; then
    echo -e "\033[0;33m$desc:\033[0m"
  fi

  if [[ -n "$def" ]]; then
    # echo -e "\033[0;33mDefined in current shell session:\033[0m"
    echo $def | pygmentize -f terminal256 -O style=native
  else
    local info=$(type -a $name 2>/dev/null)

    if [[ -n "$info" ]]; then
      echo -e "\033[0;33m$info:\033[0m"
      echo $(echo $info | cut -d ' ' -f 3-) | head -n 1 | pygmentize -f terminal256 -O style=native
    else
      echo "$name not found"
      return 1
    fi
  fi
}

#+end_src
** Term-formatting
*** color
USAGE:
=[echo ERROR | color red] || [echo ERROR | color 69]=
#+begin_src shell
color() {
    local input
    read input
    local color_code

    # Check if the argument is a number
    if [[ $1 =~ ^[0-9]+$ ]]; then
        color_code=$1
    else
        # Convert color name to color code
        case "$1" in
            black) color_code=0 ;;
            red) color_code=1 ;;
            green) color_code=2 ;;
            yellow) color_code=3 ;;
            blue) color_code=4 ;;
            magenta) color_code=5 ;;
            cyan) color_code=6 ;;
            white) color_code=7 ;;
            *) color_code=7 ;; # Default to white if unknown color name
        esac
        color_code=$((color_code + 30))
    fi

    # Print colored text
    echo -e "\033[${color_code}m${input}\033[0m"
}
#+end_src
*** color-test
#+begin_src shell
colortest() {
    echo '256-Color Mode:' | color 14

    # Display color numbers
    for i in {0..255}; do
        print -Pn "%F{$i}${(l:4::0:)i}%f "
        if ((i % 16 == 15)); then
            echo
        fi
    done
}
#+end_src
* Zconvert
#+begin_src shell
# Declare an associative array to keep track of included functions
typeset -A included

zconvert() {
    local name=$1

    # Check if function has already been included
    if [[ -n "${included[$name]}" ]]; then
        return
    fi

    # Try to retrieve it as a function
    local func=$(declare -f $name)

    # If it's not a function, try to get it as an alias
    if [[ -z "$func" ]]; then
        func=$(alias $name | sed -E "s/^alias $name='(.*)'/\1/")
        if [[ -z "$func" ]]; then
            echo "No such function or alias: $name"
            return 1
        else
            # Convert alias to function
            func="$name() {\n$func\n}"
        fi
    fi

    # Mark function as included
    included[$name]=1

    # Find function or alias calls in the function's body
    local commands=$(echo "$func" | sed -n -E "s/^[[:space:]]*([a-zA-Z0-9_]+).*/\1/p")

    for command in $commands; do
        # Skip if command is a shell built-in or exists in PATH
        if [[ $(type -t "$command") != "file" ]]; then
            zconvert "$command"
        fi
    done

    # Write the function to the file
    echo "$func" >> "$name"_standalone.zsh

    # Add shebang to the start of the file
    sed -i '1i#!/usr/bin/env zsh' "$name"_standalone.zsh

    # Make the file executable
    chmod +x "$name"_standalone.zsh
}

#+end_src
* compile
#+begin_src shell

function compile() {
    if [[ -z "$1" ]]; then
        echo "Usage: compile <file>"
        return 1
    fi

    case "${1##*.}" in
        c)
            gcc -Wall -Wextra -Wpedantic -std=c99 -O2 -o "${1%.*}" "$1" && "./${1%.*}"
            ;;
        cpp)
            g++ -Wall -Wextra -Wpedantic -std=c++17 -O2 -o "${1%.*}" "$1" && "./${1%.*}"
            ;;
        py)
            python "$1"
            ;;
        lua)
            lua "$1"
            ;;
        hs)
            ghc -O2 -o "${1%.*}" "$1" && "./${1%.*}"
            ;;
        cs)
            mcs "$1" && mono "${1%.*}.exe"
            ;;
        lisp)
            sbcl --script "$1"
            ;;
        ,*)
            echo "Error: Unsupported file type"
            return 1
            ;;
    esac
}


#+end_src
* admin
** copy
#+begin_src shell
copied=()
copy() {
  local display_list=false
  local clear_list=false

  # Process options
  while getopts ":lc" opt; do
    case $opt in
      l)
        display_list=true
        ;;
      c)
        clear_list=true
        ;;
      \?)
        echo "Invalid option: -$OPTARG"
        return 1
        ;;
    esac
  done
  shift $((OPTIND -1)) # Remove options from argument list

  # Display copied list
  if $display_list; then
    if [[ ${#copied[@]} -eq 0 ]]; then
      echo "No items have been copied yet."
    else
      echo "Previously copied items:"
      printf '%s\n' "${copied[@]}"
    fi
    return 0
  fi

  # Clear copied list
  if $clear_list; then
    copied=()
    echo "Cleared the list of copied items."
    return 0
  fi

  # If no arguments are provided, use fzf to select files/directories
  if [[ $# -eq 0 ]]; then
    local selected_items=$(ls -A | fzf -m)
    if [[ -n $selected_items ]]; then
      while IFS= read -r item; do
        local source=$(realpath "$item")
        if [[ -e $source ]]; then
          copied+=("$source")
          echo "Copied: $source"
          echo -n "$source" | xclip -selection clipboard # Copy the path to clipboard
        else
          echo "The specified path does not exist: $source"
        fi
      done <<< "$selected_items"
    fi
    return 0
  fi

  # Process file paths
  while [[ $# -gt 0 ]]; do
    local source=$(realpath "$1") # Convert to absolute path

    if [[ ! -e $source ]]; then
      echo "The specified path does not exist: $source"
    else
      copied+=("$source")
      echo "Copied: $source"
      echo -n "$source" | xclip -selection clipboard # Copy the path to clipboard
    fi
    shift
  done
}
#+end_src
*** paste
#+begin_src shell
paste() { # paste copied dirs/files in other dir
  local destination=$PWD
  local move=false
  if ! command -v fzf &> /dev/null; then
    echo "fzf is required but not installed. Aborting."
    return 1
  fi
  while getopts ":mh" opt; do
    case $opt in
      m)
        move=true
        ;;
      h)
        echo "Usage: paste [-m] [-h] (move)"
        return 0
        ;;
      \?)
        echo "Invalid option: -$OPTARG"
        return 1
        ;;
    esac
  done
  if [[ ${#copied[@]} -eq 0 ]]; then
    echo "No items have been copied yet."
    return 1
  fi
  selected_items=$(printf "%s\n" "${copied[@]}" | splittedfzf --multi)
  if [[ -z "$selected_items" ]]; then
    echo "No items selected. Aborting."
    return 1
  fi
  if [[ $# -gt 0 ]]; then
    destination="$1"
    shift
  fi
  if [[ ! -d $destination ]]; then
    echo "The destination path is not a valid directory: $destination"
    return 1
  fi
  while read -r item; do
    if $move; then
      if [[ -e $item ]]; then
        mv -f "$item" "$destination" 2>/dev/null
        echo "Moved: $item to $destination"
      fi
    else
      if [[ -e $item ]]; then
        cp -rf "$item" "$destination" 2>/dev/null
        echo "Copied: $item to $destination"
      fi
    fi

    # Remove the pasted/moved item from the 'copied' array
    copied=("${copied[@]/$item}") # This line replaces the item with an empty string
    copied=(${copied[@]}) # This line removes empty strings from the array
  done <<< "$selected_items"
}
alias splittedfzf='fzf-tmux -x --height ${FZF_TMUX_HEIGHT:-40%} -m --reverse --ansi'
#+end_src
** mdir
#+begin_src shell
function mdir () {
  command mkdir -p "$@" && c "${@: -1}" && c
}
#+end_src
** rmdir
#+begin_src shell
rmdir() {
  if [ -d "$1" ]; then
    rm -rf "$1"
  else
    echo "Error: '$1' is not a directory"
  fi
}
#+end_src
** mvall
#+begin_src shell
function mvall() {
  # Get the destination path from the first argument
  dest_path="$1"

  # Create the destination directory if it doesn't exist
  mkdir -p "$dest_path"

  # Move all files and directories in the current directory to the destination directory, excluding .git
  rsync -av --exclude=".git" --remove-source-files . "$dest_path"
}
#+end_src
** cpall
#+begin_src shell
function cpall() {
  # Get the destination path from the first argument
  dest_path="$1"

  # Create the destination directory if it doesn't exist
  mkdir -p "$dest_path"

  # Copy all files and directories in the current directory to the destination directory, excluding .git
  rsync -av --exclude=".git" . "$dest_path"
}
#+end_src
** rmall
#+begin_src shell
function rmall () {
  current_dir=$(pwd)
  case "$1" in
    -f)  # remove all files
      noglob find "$current_dir" -mindepth 1 -maxdepth 1 -type f ! -name ".gitignore" -exec rm -f {} +
      ;;
    -d)  # remove all directories
      noglob find "$current_dir" -mindepth 1 -maxdepth 1 -type d ! -name ".git" -exec rm -rf {} +
      ;;
    *)  # remove all files and directories
      noglob find "$current_dir" -mindepth 1 -maxdepth 1 ! -name ".git" -exec rm -rf {} +
      ;;
  esac
}
#+end_src
* enviroment
** variables
#+begin_src shell
here=$PWD
#+end_src
* SSH
** key
*TODO:*
- key gen    []
- key delall []
#+begin_src shell
function key() {
  case "$1" in
    list)
      # List all SSH keys with Dracula theme
      echo -e "\033[0;35m=== SSH Keys ===\033[0m"
      for file in ~/.ssh/*.pub; do
        echo -e "\033[0;32m$(basename "$file")\033[0m"
      done
      ;;
    edit)
      # Template for editing SSH keys
      echo -e "\033[0;36m=== Edit SSH Keys ===\033[0m"
      echo "TODO: Add your key edit code here"
      ;;
    ,*)
      # Invalid option
      echo -e "\033[0;31mInvalid option. Usage: key [list|edit]\033[0m"
      ;;
  esac
}

#+end_src
** delete all keys
#+begin_src shell
function ssh-delete-all-keys() {
    echo "Deleting all local SSH keys..."
    rm -rf ~/.ssh/*
    echo "All local SSH keys have been deleted."
}

#+end_src
** generate-ssh-key
#+begin_src shell

function ssh-key-generate-interactive() {
    local email
    local key_name

    echo -e "\033[0;35m======= Generate SSH Key =======\033[0m"

    # Prompt for email
    echo -e "\033[0;36mEnter your email address:\033[0m"
    read email

    # Prompt for key name
    echo -e "\033[0;36mEnter a name for your SSH key:\033[0m"
    read key_name

    if [ -z "$email" ] || [ -z "$key_name" ]; then
        echo -e "\033[0;31mPlease provide an email address and a key name.\033[0m"
        return 1
    fi

    echo -e "\033[0;35m======= Generating SSH Key =======\033[0m"
    ssh-keygen -t rsa -b 4096 -C "$email" -f "$HOME/.ssh/$key_name"

    echo -e "\033[0;35m======= SSH Key Generated =======\033[0m"
    echo -e "\033[0;32mPublic key: $HOME/.ssh/$key_name.pub\033[0m"
    echo -e "\033[0;32mPrivate key: $HOME/.ssh/$key_name\033[0m"

    echo -e "\033[0;35mTo use this SSH key, you can add it to your GitHub account or other remote systems.\033[0m"
}
#+end_src

* ARCHISO-UTILS
** Iso-init
#+begin_src shell
function iso-init() {
  # Check if archiso package is installed
  if ! command -v mkarchiso &>/dev/null; then
    # Archiso package not found, prompt to install it
    read -p "The 'archiso' package is required but not installed. Do you want to install it? (y/n): " choice
    if [[ $choice =~ ^[Yy]$ ]]; then
      # Install archiso package using sudo pacman
      sudo pacman -S archiso
    else
      echo "Aborted. 'archiso' package not installed."
      return 1
    fi
  fi

  # Set Dracula colorscheme
  export LSCOLORS="Gxfxcxdxbxegedabagacad"
  export LS_COLORS="$LS_COLORS:ow=1;36:"

  # Copy archiso configs
  sudo cp -r /usr/share/archiso/configs/releng/ "$PWD"
}
#+end_src
** Iso-build
#+begin_src shell
function iso-build {
  local script_dir="$(dirname "$0")"
  local releng_dir="$(realpath "$script_dir/releng")"
  local previous_dir="$(realpath "$script_dir/..")"
  local output_dir="$PWD/output"

  # Check if the releng_dir exists
  if [[ ! -d $releng_dir ]]; then
    # Try to find it in the previous directory
    releng_dir="$previous_dir/releng"
    if [[ -d $releng_dir ]]; then
      echo -e "\033[33mWarning: The releng directory was not found in the initial location. However, it has been found in $releng_dir\033[0m"
      l2 "$previous_dir"
      echo -e -n "\033[32mIs it OK to proceed with this directory? (y/n): \033[0m"
      read answer
      if [[ $answer != "y" ]]; then
        echo -e "\033[31mAborted\033[0m"
        return 1
      fi
    else
      echo -e "\033[31mError: $releng_dir is not a directory\033[0m"
      return 1
    fi
  fi

  # Create the output directory if it doesn't exist
  mkdir -p "$output_dir" 2>/dev/null

  # Build the ISO image
  sudo mkarchiso -v -w "$PWD/iso" -o "$output_dir" "$releng_dir" 2>/dev/null

  # Check if mkarchiso command was successful
  if [ $? -eq 0 ]; then
    # Display a success message in green
    echo -e "\033[32mSuccess! ISO image has been built in $output_dir/\033[0m"
  else
    # Display an error message in red
    echo -e "\033[31mError: ISO image creation failed!\033[0m"
    return 1
  fi
}
#+end_src

* Prompt
owerwrite the fallback prompt
#+begin_src shell
eval "$(starship init zsh)"
# eval "$(oh-my-posh init zsh)"
#+end_src
* DESKTOP
** xrate
*USAGE:* =xrate 144= or =xrate 60=
will set the refresh rate
#+begin_src shell
function xrate() {
  if [ "$#" -ne 1 ] || ! [[ "$1" =~ ^[0-9]+$ ]]; then
    echo "Usage: xrate [refresh rate]"
    return 1
  fi

  local refresh_rate=$1
  local connected_display=$(xrandr | grep ' connected' | awk '{print $1}')

  xrandr --output "$connected_display" --mode 1920x1080 --rate "$refresh_rate"
}
#+end_src
* Xos-package-manager
 no functionality from pacman will be missed
** Pullpkg
#+begin_src shell
function pullpkg() {
  HELPER=${HELPER:-yay} # Set default AUR helper to yay if HELPER variable not defined
  for pkgname in $*; do
    git clone "https://aur.archlinux.org/$pkgname.git"
    cd "$pkgname"
    "$HELPER" --downloadonly --noredownload --noconfirm
    cd ..
  done
}
#+end_src
** Get
the way to get software on xos
#+begin_src shell
get() {
  PACKAGE=$1
  FLAG=$2

  # If no-reinstall flag is specified, check if the package is already installed
  if [[ "$FLAG" == "--no-reinstall" ]]; then
    if pacman -Qs "$PACKAGE" > /dev/null ; then
      echo "$PACKAGE is already installed"
      return 0
    fi
  fi

  # If not installed or if no-reinstall flag is not specified, install the package
  if ! yay -S --noconfirm "$PACKAGE" ; then
    echo "Error installing $PACKAGE"
  fi
}
#+end_src

** Getall
usage: ~getall packages.txt~ where packages is a list of packages
getall leverages the =get= function so =--no-reinstall= can be used
#+begin_src shell
getall() {
  FILE_PATH="${1}.txt"
  FLAG=$2

  if [ ! -f "$FILE_PATH" ]; then
    echo "File $FILE_PATH does not exist."
    return 1
  fi

  while IFS= read -r PACKAGE
  do
    get "$PACKAGE" "$FLAG"
  done < "$FILE_PATH"
}
#+end_src
** Pacexport
#+begin_src shell
pacexport() {
  # Assign the second argument to the output directory, default to the current directory
  OUTPUT_DIRECTORY=${2:-$(pwd)}

  # Check if output directory exists
  if [ ! -d "$OUTPUT_DIRECTORY" ]; then
    echo "Directory $OUTPUT_DIRECTORY does not exist. Creating..."
    mkdir -p "$OUTPUT_DIRECTORY"
  fi

  # Get the list of all explicitly installed packages, format it for easier parsing
  PACKAGES=$(yay -Qqe)

  # Write the output to a file
  echo "$PACKAGES" > "${OUTPUT_DIRECTORY}/${1}.txt"

  echo "Packages exported to ${OUTPUT_DIRECTORY}/${1}.txt"
}
#+end_src

** pacanalize
*TODO:*
- pacanalize emacs should work []
  - the output is ugly         []
#+begin_src shell
function pacanalize() {
    # Fetch package data
    local all=$(pacman -Q | wc -l)
    local pkg=$(pacman -Qe | wc -l)
    local official_pkg=$(pacman -Qen | wc -l)
    local aur_pkg=$(pacman -Qem | wc -l)
    local dep_pkg=$(pacman -Qd | wc -l)
    local official_dep_pkg=$(pacman -Qdn | wc -l)
    local aur_dep_pkg=$(pacman -Qdm | wc -l)

    # Show spinner
    gum spin --title="Analyzing packages ðŸš€" -- sleep 1

    # Display the data with styling
    gum style --bold "All Packages: $all"
    gum style "  Packages: $pkg"
    gum style "    Official Packages: $official_pkg"
    gum style "    AUR Packages: $aur_pkg"
    gum style "  Dependent Packages: $dep_pkg"
    gum style "    Official Dependent Packages: $official_dep_pkg"
    gum style "    AUR Dependent Packages: $aur_dep_pkg"
}
#+end_src
** pacinfo
#+begin_src shell
pacinfo() {
    if [ $# -eq 0 ]; then
        echo "Error: Please provide at least one package name." | color red
        return 1
    fi

    for pkg in "$@"; do
        local info=$(pacman -Qi $pkg)

        if [ -z "$info" ]; then
            echo "Error: Package '$pkg' not found." | color red
            continue
        fi

        echo -e "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | color blue
        echo " Package Information for $pkg " | color blue
        echo -e "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" | color blue

        echo "$info" | while read -r line; do
            case "$line" in
                Name*)
                    echo "$line" | color green;;
                Version*)
                    echo "$line" | color purple;;
                Description*)
                    echo "$line" | color yellow;;
                Architecture*)
                    echo "$line" | color cyan;;
                URL*)
                    echo "$line" | color blue;;
                Licenses*)
                    echo "$line" | color green;;
                Groups*)
                    echo "$line" | color yellow;;
                Provides*)
                    echo "$line" | color cyan;;
                Depends*)
                    echo "$line" | color purple;;
                Optional*)
                    echo "$line" | color red;;
                Conflicts*)
                    echo "$line" | color red;;
                Installed*)
                    echo "$line" | color cyan;;
                *)
                    echo "$line" | color white;;
            esac
        done
    done
}
#+end_src
**** _pacinfo
#+begin_src shell
_pacinfo() {
    local state line
    typeset -A opt_args

    _arguments -C \
        '1: :->packages' \
        '*:: :->other'

    case $state in
        packages)
            local -a completions
            completions=($(pacman -Qq))
            _describe 'packages' completions
            ;;
        other)
            ;;
    esac
}

# Register the _pacinfo function for autocompletion with pacinfo
compdef _pacinfo pacinfo
#+end_src

* my-useless-creations
** freedom
it doesnt actually work
#+begin_src shell
function freedom() {
  for package in $(pacman -Qq); do
    license=$(pacman -Qi $package | awk '/License/ { print $3 }')
    if [[ $license =~ "custom:..(noncommercial|nolicense|permissive)" || $license =~ "AGPL" || $license =~ "Apache" || $license =~ "Artistic" || $license =~ "BSD" || $license =~ "CC-BY" || $license =~ "CC-BY-NC" || $license =~ "CC-BY-ND" || $license =~ "CC-BY-SA" || $license =~ "CC-BY-NC-SA" || $license =~ "CDDL" || $license =~ "EPL" || $license =~ "GPL" || $license =~ "LGPL" || $license =~ "MIT" || $license =~ "MPL" || $license =~ "OpenSSL" || $license =~ "Python" || $license =~ "W3C" || $license =~ "Zlib" ]]; then
      echo -e "${package}\t\e[32mFREE\e[0m"
    else
      echo -e "${package}\t\e[31mPROPRIETARY\e[0m"
    fi
  done
}
#+end_src
* XORG-TOOL-BOX
** start
#+begin_src shell
function start() {
  if [[ -z $1 ]]; then
    startx
  else
    set-wm "$1" && startx
  fi
}
#+end_src
*** SET-WM
#+begin_src shell
function set-wm() {
    local program_name="$1"
    local xinitrc_file="/etc/X11/xinit/xinitrc"
    if sudo sed -i "\$s|^exec.*|exec $program_name|" "$xinitrc_file"; then
        echo "Last 'exec' line updated in $xinitrc_file"
    else
        echo "No 'exec' line found in $xinitrc_file"
    fi
}
#+end_src
** Reset-xinit
*DON'T WORK*
=Pkill xinit && start=
#+begin_src shell
# function reset_xinit() {
#   nohup zsh -i -c "pkill -9 xinit; sleep 2; sudo chvt 1; openvt -s your_alias_here" >/dev/null 2>&1 &
#   disown
# }
#+end_src
** autologin
Toggle systemd autologin for current user
#+begin_src shell
function autologin() {
        if [[ "$1" == "info" ]]; then
            local tty_number="1"
            local service_file="/etc/systemd/system/getty@tty${tty_number}.service.d/autologin.conf"
            if [[ -f "$service_file" ]]; then
                echo "Auto-login enabled"
            else
                echo "Auto-login disabled"
            fi
        else
            local tty_number="1"
            local service_dir="/etc/systemd/system/getty@tty${tty_number}.service.d"
            local service_file="$service_dir/autologin.conf"
            local current_user=$(whoami)
            if [[ -f "$service_file" ]]; then
                sudo rm "$service_file" && \
                sudo systemctl daemon-reload && \
                echo "Auto-login disabled for tty${tty_number}"
            else
                if [[ ! -d "$service_dir" ]]; then
                    sudo mkdir -p "$service_dir"
                fi
                echo "[Service]
    ExecStart=
    ExecStart=-/sbin/agetty --autologin $current_user --noclear %I $TERM" | sudo tee "$service_file" > /dev/null
                sudo systemctl daemon-reload && \
                echo "Auto-login enabled for tty${tty_number} with user $current_user"
            fi
        fi
    }
#+end_src
** xgeometry
interactively click the desired window
#+begin_src shell
xgeometry() {
  xwininfo_output=$(xwininfo -frame)
  x=$(echo "$xwininfo_output" | awk '/Absolute upper-left X:/ { print $4 }')
  y=$(echo "$xwininfo_output" | awk '/Absolute upper-left Y:/ { print $4 }')
  width=$(echo "$xwininfo_output" | awk '/Width:/ { print $2 }')
  height=$(echo "$xwininfo_output" | awk '/Height:/ { print $2 }')

  echo "X: $x"
  echo "Y: $y"
  echo "Width: $width"
  echo "Height: $height"
}
#+end_src
** xgeometry_focused
output x, y, width, height about the currently focused window, WORKS WITH ANY WM
#+begin_src shell
function xgeometry-focus() {
	focused_window_id=$(xdotool getwindowfocus)
	xwininfo_output=$(xwininfo -id "$focused_window_id")
	x=$(echo "$xwininfo_output" | awk '/Absolute upper-left X:/ { print $4 }')
	y=$(echo "$xwininfo_output" | awk '/Absolute upper-left Y:/ { print $4 }')
	width=$(echo "$xwininfo_output" | awk '/Width:/ { print $2 }')
	height=$(echo "$xwininfo_output" | awk '/Height:/ { print $2 }')
	echo "X: $x"
	echo "Y: $y"
	echo "Width: $width"
	echo "Height: $height"
}
#+end_src
* MOTIONS
** lfcd
#+begin_src shell
lfcd () {
    tmp="$(mktemp)"
    lf -last-dir-path="$tmp" "$@"
    if [ -f "$tmp" ]; then
        dir="$(cat "$tmp")"
        rm -f "$tmp"
        [ -d "$dir" ] && [ "$dir" != "$(pwd)" ] && c "$dir"
    fi
}
#+end_src
** c
This function enhances the traditional "cd" command in several key ways:

- *Directory Creation*: If the specified directory does not exist, "c" will create it.
- *Automatic Listing*: The function immediately lists the contents of the directory you've moved into.
- *Customized Views*: The function adjusts the display based on the directory you're in. For instance, in the home directory, it uses "exa -la" for a detailed view.
- *Depth-Sensitive Viewing*: If a directory only has one depth level, the function uses a tree view.
- *Enhanced Navigation*: The process of moving to a new directory, viewing its contents, and creating new directories is significantly simplified.
#+begin_src shell
function c() {
    local dir="$1"
    if [[ -z "$dir" ]]; then
        dir="."
    fi

    clear
    if [[ ! -d "$dir" ]]; then
        mkdir -p "$dir"
    fi
    cd "$dir"

    if [[ "$PWD" == "$HOME" ]]; then
        exa -la
    elif [[ "$PWD" == "$HOME/xos" ]]; then
        exa -la
    elif [[ "$PWD" == "$HOME/Desktop/test" ]]; then
        exa -la
    elif [[ "$PWD" == "$HOME/Desktop/pulls/dotfiles/.config" ]]; then
        exa -la
    else
        local subdir
        local use_l=false
        for subdir in $(find . -maxdepth 1 -type d)
        do
            if [[ $(find $subdir -maxdepth 1 -type d | wc -l) -eq 1 && $(find $subdir -maxdepth 1 -type f | wc -l) -gt 0 ]]; then
                use_l=true
                break
            fi
        done

        if [[ "$use_l" == true ]]; then
            l
        else
            lsd
        fi
    fi
}
#+end_src
** ls
fuck your plain ls, bloat the system its free:
#+begin_src shell
# ls() {
#     local dir="$1"
#     if [[ -z "$dir" ]]; then
#         dir="."
#     fi

#     if [[ "$PWD" == "$HOME" ]]; then
#         exa -la
#     elif [[ "$PWD" == "$HOME/xos" ]]; then
#         lsd --tree --depth=2
#     else
#         local subdir
#         local use_l=false
#         for subdir in $(find . -maxdepth 1 -type d)
#         do
#             if [[ $(find $subdir -maxdepth 1 -type d | wc -l) -eq 1 && $(find $subdir -maxdepth 1 -type f | wc -l) -gt 0 ]]; then
#                 use_l=true
#                 break
#             fi
#         done

#         if [[ "$use_l" == true ]]; then
#             l
#         else
#             lsd
#         fi
#     fi
# }
#+end_src

** test
#+begin_src shell
function test() {
    c ~/Desktop/test/$1/$2/$3
}
#+end_src
** script
#+begin_src shell
function script() {
    c ~/xos/script/$1/$2/$3
}
#+end_src
** xos
#+begin_src shell
function xos() {
    c ~/xos/$1/$2/$3
}
#+end_src
** dotfiles
#+begin_src shell
function dotfiles() {
  c ~/Desktop/pulls/dotfiles/$1/$2/$3
}
#+end_src
** conf
#+begin_src shell
function conf() {
  local x=~/.config
  for arg in $@; do
    x+="/$arg"
  done
  if [ -d "$x" ]; then
    cd "$x"
  else
    echo "Directory not found: $x"
  fi
}
#+end_src
*** _conf
#+begin_src shell
_conf() {
  local curcontext="$curcontext" state line
  _path_files -W "$HOME/.config/" && return
  return 1
}
compdef _conf conf
#+end_src
* GIT
** gclone
git clone, but you can display a custom image
#+begin_src shell
function gclone() {
  clear
  if [ $# -lt 1 ]; then
    echo "Usage: gclone <repository> [directory]"
    return 1
  fi

  # Set the repository URL and directory name from the input arguments
  local repo="$1"
  local dir="$2"

  # Display the cloning image inside the terminal using kitty icat
  kitty +kitten icat ~/Desktop/xos/xassets/git.png

  # Use the name of the repository as the directory name if none is provided
  if [ -z "$dir" ]; then
    dir=$(basename "$repo" .git)
  fi

  # Clone the repository into the specified directory and change into the cloned directory
  git clone "$repo" "$dir" && c "$dir"
}
#+end_src
** gitgo
#+begin_src shell
gitgo() {
    # Check if inside a git repository
    if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        # Extract the remote repository URL
        remote_url=$(git config --get remote.origin.url)
        # Convert git URL to HTTPS URL if needed
        if [[ "$remote_url" == git@github.com:* ]]; then
            remote_url=${remote_url/git@github.com:/https://github.com/}
            remote_url=${remote_url%.git}
        fi
        # Open the remote URL in the default web browser
        xdg-open "$remote_url"
    else
        # If not inside a git repository, open the GitHub homepage
        xdg-open "https://github.com"
    fi
}

alias ggo='gitgo'
#+end_src
** ginit
inizialize a and push an entire directory to github
#+begin_src shell
ginit() {
  # Check if `gh` and `git` commands are installed
  command -v gh >/dev/null 2>&1 || { echo >&2 "The 'gh' command is required. Please install it before running this function."; return 1; }
  command -v git >/dev/null 2>&1 || { echo >&2 "The 'git' command is required. Please install it before running this function."; return 1; }

  # Check if repository name is provided
  if [ -z "$1" ]; then
    echo "Please provide a repository name as an argument."
    return 1
  fi

  # Options
  local commit_message="first commit"
  local branch_name="main"

  # Check if directory size exceeds 2 GB
  if [ "$(du -sb . | cut -f1)" -gt $((2*1024*1024*1024)) ]; then
    echo "The directory size exceeds 2 GB. Aborting."
    return 1
  fi

  # Create the repository on GitHub
  echo "Creating repository $1 on GitHub..."
  gh repo create "$1" --public

  # Initialize the local Git repository
  echo "Initializing local Git repository..."
  git init

  # Copy the README.md file to the current directory
  # echo "Copying README.md file..."
  # cp ~/Desktop/test/smart-git/BLANK_README.md README.md
  # cp -R ~/Desktop/test/smart-git/images .


  # Add all files in current directory to the staging area
  echo "Adding all files to the staging area..."
  git add .

  # Commit the changes
  echo "Committing changes..."
  git commit -m "$commit_message"

  # Rename the default branch to main
  echo "Renaming default branch to $branch_name..."
  git branch -M "$branch_name"

  # Set the remote origin to the GitHub repository
  echo "Setting remote origin to GitHub repository..."
  git remote add origin "https://github.com/laluxx/$1.git"

  # Push the changes to the remote repository
  echo "Pushing changes to remote repository..."
  git push -u origin "$branch_name"

  echo "Done!"
}
#+end_src
** clone
clone directly from you GH account
#+begin_src shell
function clone() {
    local github_account="laluxx"
    git clone "https://github.com/${github_account}/$1.git"
}
#+end_src
** origin
#+begin_src shell
function origin() {
  gh repo set-default
}
#+end_src
** rmrepo
#+begin_src shell
#TODO
function rmrepo() {
  repo_name="$1"
  gh repo delete "$repo_name" --yes
}
#+end_src
** pulls
#+begin_src shell
function pulls(){
  c ~/Desktop/pulls/$1/$2/$3
}
#+end_src
** dd-iso
#+begin_src shell
#TODO
function dd_iso() {
  # Define a function to show the lsblk output with custom formatting and color
  function show_lsblk() {
    lsblk --fs --output NAME,FSTYPE,LABEL,SIZE,MOUNTPOINT | awk '{ printf "\e[1m%-20s %-10s %-10s %-10s %-20s\e[0m\n", $1, $2, $3, $4, $5 }'
  }

  # Define a function to show the ISO file description
  function show_iso_description() {
    if [[ -n $iso ]]; then
      echo -e "\e[1mISO file information:\e[0m"
      isoinfo -d -i "$iso" | sed 's/^/  /'
    fi
  }

  # Use fzf to select an ISO file from the ~/Downloads/iso directory
  iso=$(find ~/Downloads/iso -maxdepth 1 -type f -name "*.iso" | fzf --prompt "Select an ISO file: " \
    --preview-window=right:60% \
    --preview="echo -e \"\e[1mSelected ISO file:\e[0m\n  {}\"; show_iso_description")

  # Exit if no ISO file is selected
  if [[ -z $iso ]]; then
    echo "No ISO file selected."
    return
  fi

  # Use lsblk with custom formatting to select a disk to write to
  disk=$(lsblk --noheadings --list --output NAME,SIZE | fzf --prompt "Select a disk to write to: " \
    --preview-window=right:60% \
    --preview="echo -e \"\e[1mSelected disk:\e[0m\n  {}\"; show_lsblk | grep -E \"(^| ){}($| )\"")

  # Exit if no disk is selected
  if [[ -z $disk ]]; then
    echo "No disk selected."
    return
  fi

  # Print lsblk output with custom formatting and color
  show_lsblk

  # Prompt the user for confirmation before proceeding
  read -rp "Are you sure you want to write $iso to $disk? (y/N) " confirm
  if [[ ! $confirm =~ ^[yY]$ ]]; then
    echo "Aborting."
    return
  fi

  # Use dd to write the selected ISO file to the selected disk
  echo "Writing $iso to $disk..."
  sudo dd bs=4M if="$iso" of="/dev/$disk" status=progress conv=fsync oflag=direct
  echo "Done!"
}
#+end_src
* XOS
** XOS-UPDATE
#+begin_src shell
function xos-update() {
    local xos_path="$HOME/xos"
    local dotfiles_repo="https://github.com/laluxx/dotfiles.git"
    local destination_dir="$HOME/Desktop/pulls/dotfiles"

    # Silently change to the xos directory
    cd "$xos_path" || return 1

    # Remove the existing dotfiles directory if it exists
    [[ -d dotfiles ]] && rm -rf dotfiles

    # Clone the dotfiles repository
    git clone --quiet "$dotfiles_repo" dotfiles || return 1

    # Rsync the dotfiles directory to your local repository
    rsync -a "$xos_path/dotfiles/" "$destination_dir/"

    echo "XOS updated"

    # Call the update-dotfiles function to sync to home directory
    update-dotfiles
}
#+end_src
*** UPDATE DOTFILES
#+begin_src shell
function update-dotfiles() {
    dotfiles_path="$HOME/Desktop/pulls/dotfiles"

    rsync -a "$dotfiles_path"/. "$HOME"/
    echo "Updated dotfiles"
}
#+end_src
** xos-doctor
#+begin_src shell
function xos-doctor() {
    sudo lynis audit system
}
#+end_src
* gUM
** theme
#+begin_src shell
# export GUM_INPUT_CURSOR_FOREGROUND=""
export GUM_INPUT_PROMPT_FOREGROUND="#A3F7FF"
export GUM_INPUT_PLACEHOLDER="What's up?"
export GUM_INPUT_PROMPT="âžœ "
export GUM_INPUT_WIDTH=80
#+end_src
** gum-commit
#+begin_src sh
function gum-commit(){
TYPE=$(gum choose "fix" "feat" "docs" "style" "refactor" "test" "chore" "revert")
SCOPE=$(gum input --placeholder "scope")

# Since the scope is optional, wrap it in parentheses if it has a value.
test -n "$SCOPE" && SCOPE="($SCOPE)"

# Pre-populate the input with the type(scope): so that the user may change it
SUMMARY=$(gum input --value "$TYPE$SCOPE: " --placeholder "Summary of this change")
DESCRIPTION=$(gum write --placeholder "Details of this change (CTRL+D to finish)")

# Commit these changes
gum confirm "Commit changes?" && git commit -m "$SUMMARY" -m "$DESCRIPTION"
}
#+end_src
* INSTANT-MENU
#+begin_src shell
# Define Color Schemes
typeset -A color_schemes
color_schemes=(
  'dracula' '#282A36 #F8F8F2 #FF79C6 #F8F8F2'
  'doom-one' '#282c34 #bbc2cf #98be65 #282c34'
  # Format 'name' 'background foreground selection selected_text'
)

# ZSH function for Instant Menu
instant_menu() {
  # Select the color scheme
  local -a colors
  IFS=' ' read -r -A colors <<< "${color_schemes[$1]}"

  # Generate menu
  programs=$(ls /usr/bin | sort -u)
  chosen=$(echo -e "$programs" | instantmenu -i -l 20 -h 30 -w 600 \
      -x $(( ($(xdotool getdisplaygeometry | cut -d ' ' -f1) - 600) / 2 )) \
      -y $(( ($(xdotool getdisplaygeometry | cut -d ' ' -f2) - 600) / 2 )) \
      -nb ${colors[1]} -nf ${colors[2]} -sb ${colors[3]} -sf ${colors[4]})

  # Run chosen program
  [[ -n $chosen ]] && $chosen &
}

# Usage: instant_menu 'dracula'
#        instant_menu 'doom-one'
#+end_src

* WAL
** gtkset
for darkarch theme
#+begin_src shell
gtkset () {
    new_color=$(awk '/color5/{print $2}' $HOME/.cache/wal/colors-kitty.conf)
    if [ -n "$new_color" ]; then
        sed -i "s/@define-color accent #[^;]*;/@define-color accent $new_color;/g" $HOME/.local/share/themes/darkwal/gtk-3.0/gtk.css
    else
        echo "No color5 found in colors-kitty.conf"
    fi
}
#+end_src
** gtkset2
for flatcolor theme
*TODO:*
- it changes the gtk.css file but nothing actually change
#+begin_src shell
gtkset2 () {
    file_path="$HOME/.cache/wal/colors-kitty.conf"
    theme_file="$HOME/.local/share/themes/FlatColor/gtk-3.0/gtk.css"

    declare -a css_color_names=("bg_color" "fg_color" "base_color" "text_color" "selected_bg_color"
                                "selected_fg_color" "tooltip_bg_color" "tooltip_fg_color" "light_shadow"
                                "dark_shadow" "info_fg_color" "info_bg_color" "warning_fg_color"
                                "warning_bg_color" "question_fg_color" "question_bg_color" "error_fg_color"
                                "error_bg_color" "border_color" "button_normal_color" "button_info_color"
                                "entry_border_color" "frame_border_bottom_color" "sel_color" "switch_bg_color"
                                "panel_bg_color" "panel_fg_color" "scrollbar_trough" "osd_separator" "osd_fg"
                                "osd_bg" "wm_bg" "wm_title_focused" "wm_title_unfocused" "wm_border_focused"
                                "wm_border_unfocused")

    for i in {0..15}; do
        color=$(awk -v color="color$i" '$1==color{print $2}' $file_path)
        if [ -n "$color" ]; then
            sed -i "s/@define-color ${css_color_names[$i]} #[^;]*;/@define-color ${css_color_names[$i]} $color;/g" $theme_file
        else
            echo "No color$i found in colors-kitty.conf"
        fi
    done
}

#+end_src
** wal-set
#+begin_src shell
# TODO: set emacs theme too [x]
# TODO: compile spaceline []
wal-set () {
    local dir=~/xos/wallpapers/static
    local wallpaper=$(find "$dir" \( -name "*.png" -o -name "*.jpg" -o -name "*.jpeg" -o -name "*.webp" \) -type f | fzf --height 40% -m --reverse --ansi --cycle)
    if [[ -n "$wallpaper" ]]
    then
        wal -i "${wallpaper}" # -q
        echo "${wallpaper}" > ~/xos/theme/.wallpaper
        theme pywal --no-random  #set gtk theme cursor icons, and picom
        python3 ~/xos/pywal-scripts/xmonad-dark-wal.py    # DARK THEME
        # python3 ~/xos/pywal-scripts/xmonad-light-wal.py # LIGHT THEME

        python3 ~/xos/pywal-scripts/nvim-wal.py          # GEN NVCHAD TRASPARENT THEME
        python3 ~/xos/pywal-scripts/nvim-wal-dark.py   # GEN NVCHAD DARK THEME

        # python3 ~/xos/pywal-scripts/org-bullets.py       # TODO GEN org-colors-wal
        xmonad --restart
        oomox-gtk-gen
        papirus-wal # set icon                             # TODO ask for sudo password and slow
    else
        # echo "No wallpaper selected."
    fi

}
#+end_src
* Qr
generate qrcodes of text/links
** qr-gen
#+begin_src shell
qr-gen() {       if [ -z "$1" ]; then
        echo "Usage: qrgen <text_or_url>"
        return 1
      fi
      local input="$1"
      local api_url="https://qrenco.de/$input"
      curl -s $api_url || echo "Failed to generate QR Code."
    }
#+end_src

#+RESULTS:

** qr-scan
#+begin_src shell
qr-scan() {
    # Create a temporary file to store the screenshot
    tmpfile=$(mktemp /tmp/qr-scan.XXXXXX.png)

    # Take a screenshot of a selected region and save it to the temporary file
    maim -s "$tmpfile"

    # Scan the QR code in the screenshot
    url=$(zbarimg --raw --quiet "$tmpfile")

    # Remove the temporary file
    rm "$tmpfile"

    # Open the URL in the default web browser
    if [ -n "$url" ]; then
        xdg-open "$url"
    else
        echo "No QR code found"
    fi
}
#+end_src
* Kitty
** Grep
Better Grep
#+begin_src shell
g() {
    if [ "$#" -eq 1 ]; then
        kitty +kitten hyperlinked_grep "$1" | less
    else
        echo "Usage: g <search_text>"
    fi
}
#+end_src

* terminal-image-manipulation
TODO:
- a dashboard where you press [r, h, p] and optimize it for processing images
** img-rotate
TODO :
- if the orientation didnt change, quitting will ot save a new version
- img-rotate img.png -90 will generate the image instantly (no stdout)
#+begin_src shell
img-rotate() {
    local image_file="$1"
    local rotate_degree=0
    local rotate_step=90

    local temp_file="temp_$image_file"
    cp "$image_file" "$temp_file"

    while true; do
        render "$temp_file"

        read -rsk1 input

        if [[ "$input" == "j" ]]; then
            ((rotate_degree += rotate_step))
            convert "$temp_file" -rotate $rotate_step "$temp_file"
        elif [[ "$input" == "k" ]]; then
            ((rotate_degree -= rotate_step))
            convert "$temp_file" -rotate -$rotate_step "$temp_file"
        elif [[ "$input" == "q" || "$input" == $'\e' ]]; then
            cp "$temp_file" "${rotate_degree}degree-$image_file"
            break
        fi
    done

    mm "$temp_file"
}
#+end_src
** img-resize
#+begin_src shell
function img-resize() {
    if [ $# -ne 3 ]; then
        echo "Usage: xresize <input-file> <width> <height>"
        return 1
    fi

    local input_file="$1"
    local width="$2"
    local height="$3"
    local file_extension="${input_file##*.}"
    local output_file="${input_file%.*}${width}x${height}.${file_extension}"
    local lowercase_file_extension="$(echo "$file_extension" | tr '[:upper:]' '[:lower:]')"

    if [[ "${lowercase_file_extension}" =~ ^(jpg|jpeg|png)$ ]]; then
        convert "${input_file}" -resize "${width}x${height}" "${output_file}"
        echo "Resized ${input_file} to ${output_file}"
    else
        echo "Invalid file extension. Supported formats: jpg, jpeg, png"
        return 1
    fi
}
#+end_src
** Hue
#+begin_src shell
hue() {
    local image_file="$1"
    local hue_shift=0
    local hue_step=5

    local temp_file="temp_$image_file"

    while true; do
        convert "$image_file" -modulate 100,100,$((100 + hue_shift)) "$temp_file"
        render "$temp_file"

        read -rsk1 input

        if [[ "$input" == "j" ]]; then
            ((hue_shift += hue_step))
        elif [[ "$input" == "k" ]]; then
            ((hue_shift -= hue_step))
        elif [[ "$input" == "q" || "$input" == $'\e' ]]; then
            cp "$temp_file" "${hue_shift}hue-$image_file"
            break
        fi
    done

    rm "$temp_file"
}
#+end_src
** Palettes
*** pal-gen
#+begin_src shell
pal-gen() {
  # Get the list of palettes
  local palettes="$(lutgen -p 2>&1)"

  # Allow the user to select palettes using fzf (multiple selections allowed).
  local selected_palettes=$(echo "$palettes" | tr ',' '\n' | fzf --multi)

  # Check if the user made a selection
  if [ -z "$selected_palettes" ]; then
    echo "No palette selected"
    return
  fi

  # Generate a LUT image for each selected palette
  # Here we use a while loop to read through newline-separated values
  while read -r palette; do
    if [ -n "$palette" ]; then
      local trimmed_palette=$(echo $palette | xargs) # Remove leading/trailing whitespaces
      echo "Generating LUT for $trimmed_palette"
      lutgen -p $trimmed_palette -o "${trimmed_palette}_lut.png"
    fi
  done <<< "$selected_palettes"
}
#+end_src
*** Pal
#+begin_src shell
pal () {
   # local palettes=("catppuccin-frappe" "catppuccin-latte" "catppuccin-macchiato" "catppuccin-mocha" "catppuccin-oled" "adventuretime" "material-palenight-base16" "palenighthc" "tokyonight-moon" "tokyonight-night" "doomone" "cupcake-base16" "dracula" "espresso" "rose-pine" "rose-pine-dawn" "rose-pine-moon" "mocha-light-terminal-sexy" "mocha-base16" )
    local selected_palettes selected_images apply_wallpaper=false


    local palettes=("abernathy" "aci-gogh" "aco-gogh" "adventure" "adventuretime" "afterglow" "afterglow-gogh" "alabaster" "alienblood" "andromeda" "apathy-base16" "apple-classic" "apprentice-base16" "argonaut" "arthur" "ashes-base16" "ashes-light-terminal-sexy" "atelier-cave-base16" "atelier-cave-light-base16" "atelier-dune-base16" "atelier-dune-light-base16" "atelier-estuary-base16" "atelier-estuary-light-base16" "atelier-forest-base16" "atelier-forest-light-base16" "atelier-heath-base16" "atelier-heath-light-base16" "atelier-lakeside-base16" "atelier-lakeside-light-base16" "atelier-plateau-base16" "atelier-plateau-light-base16" "atelier-savanna-base16" "atelier-savanna-light-base16" "atelier-seaside-base16" "atelier-seaside-light-base16" "atelier-sulphurpool-base16" "atelier-sulphurpool-light-base16" "ateliersulphurpool" "atelierdune-dark-terminal-sexy" "atelierdune-light-terminal-sexy" "atelierforest-dark-terminal-sexy" "atelierforest-light-terminal-sexy" "atelierheath-dark-terminal-sexy" "atelierheath-light-terminal-sexy" "atelierlakeside-dark-terminal-sexy" "atelierlakeside-light-terminal-sexy" "atelierseaside-dark-terminal-sexy" "atelierseaside-light-terminal-sexy" "atlas-base16" "atom" "atomonelight" "aura-gogh" "aurora" "ayu-dark-gogh" "ayu-light-gogh" "ayu-mirage" "ayu-mirage-gogh" "azu-gogh" "banana-blueberry" "batman" "belafonte-day" "belafonte-night" "belge-terminal-sexy" "bespin-base16" "bespin-light-terminal-sexy" "bim-gogh" "birdsofparadise" "bitmute-terminal-sexy" "black-metal-bathory-base16" "black-metal-burzum-base16" "black-metal-dark-funeral-base16" "black-metal-gorgoroth-base16" "black-metal-immortal-base16" "black-metal-khold-base16" "black-metal-marduk-base16" "black-metal-mayhem-base16" "black-metal-nile-base16" "black-metal-venom-base16" "black-metal-base16" "blazer" "bleh1-terminal-sexy" "blue-matrix" "blueberrypie" "bluedolphin" "bluloco-light-gogh" "bluloco-zsh-light-gogh" "blulocodark" "blulocolight" "borland" "breath-gogh" "breath-darker-gogh" "breath-light-gogh" "breath-silverfox-gogh" "breeze" "breeze-gogh" "brewer-base16" "brewer-light-terminal-sexy" "bright-base16" "bright-lights" "broadcast" "brogrammer" "brogrammer-base16" "brush-trees-base16" "brush-trees-dark-base16" "builtin-dark" "builtin-light" "builtin-pastel-dark" "builtin-solarized-dark" "builtin-solarized-light" "builtin-tango-dark" "builtin-tango-light" "c64" "cga" "clrs" "cai-gogh" "calamity" "canvased-pastel-terminal-sexy" "catch-me-if-you-can-terminal-sexy" "catppuccin-frappe" "catppuccin-latte" "catppuccin-macchiato" "catppuccin-mocha" "catppuccin-oled" "chalk" "chalk-gogh" "chalk-base16" "chalk-light-terminal-sexy" "chalkboard" "challengerdeep" "chameleon-gogh" "chester" "ciapre" "circus-base16" "city-streets-terminal-sexy" "classic-dark-base16" "classic-light-base16" "clone-of-ubuntu-gogh" "cloud-terminal-sexy" "cobalt-neon" "cobalt2" "codeschool-base16" "codeschool-light-terminal-sexy" "color-star-terminal-sexy" "colorcli-gogh" "colorful-colors-terminal-sexy" "colors-base16" "count-von-count-terminal-sexy" "crayonponyfish" "cupcake-base16" "cupertino-base16" "cyberdyne" "dwm-rob-terminal-sexy" "danqing-base16" "danqing-light-base16" "darcula-base16" "dark-ocean-terminal-sexy" "dark-pastel" "dark-plus" "dark-violet-base16" "darkside" "darktooth-base16" "dawn-terminal-sexy" "day3024" "deafened-terminal-sexy" "decaf-base16" "default-light-terminal-sexy" "default-dark-base16" "default-light-base16" "dehydration-gogh" "derp-terminal-sexy" "desert" "digerati-terminal-sexy" "dimmedmonokai" "dissonance-gogh" "django" "djangorebornagain" "djangosmooth" "doom-peacock" "doomone" "dotgov" "dotshare-terminal-sexy" "dracula" "duotone-dark" "encom" "earthsong" "edge-dark-base16" "edge-light-base16" "efautumn" "efbio" "efcherie" "efdark" "efspring" "efsummer" "eftriodark" "eftriolight" "eftritanopiadark" "efwinter" "eighties-base16" "eighties-light-terminal-sexy" "eldorado-dark-terminal-sexy" "elemental" "elementary" "elementary-gogh" "elic-gogh" "elio-gogh" "embers-base16" "embers-light-terminal-sexy" "epiphany-terminal-sexy" "eqie6-terminal-sexy" "equilibrium-dark-base16" "equilibrium-gray-dark-base16" "equilibrium-gray-light-base16" "equilibrium-light-base16" "erebus-terminal-sexy" "espresso" "espresso-base16" "espresso-libre" "euphrasia-terminal-sexy" "eva-base16" "eva-dim-base16" "everbl-sh" "everforest-dark-gogh" "everforest-light-gogh" "fahrenheit" "fairy-fl-ss-gogh" "fairy-fl-ss-dark-gogh" "fairyfl-ss" "farside-terminal-sexy" "fideloper" "firefoxdev" "firewatch" "fishtank" "fishbone-terminal-sexy" "flat" "flat-gogh" "flat-base16" "flat-remix-gogh" "flatland" "floraverse" "forestblue" "foxnightly-gogh" "framer" "framer-base16" "freya-gogh" "frontenddelight" "fruit-soda-base16" "funforrest" "gjm-terminal-sexy" "galaxy" "galizur" "geohot-gogh" "gigavolt-base16" "github-dark" "github" "github-base16" "glacier" "gogh-gogh" "gooey-gogh" "google-light-terminal-sexy" "google-dark-gogh" "google-dark-base16" "google-light-gogh" "google-light-base16" "gotham-gogh" "grandshell-terminal-sexy" "grape" "grass" "grayscale-light-terminal-sexy" "grayscale-dark-base16" "grayscale-light-base16" "green-screen-base16" "greenscreen-light-terminal-sexy" "greygreen" "gruber-base16" "gruvbox-dark" "gruvbox-dark-hard" "gruvbox-dark-soft" "gruvbox-light" "gruvbox-light-hard" "gruvbox-light-soft" "guezwhoz" "hax0r-blue" "hax0r-gr33n" "hax0r-r3d" "hacktober" "hardcore" "hardcore-base16" "harmonic16-dark-base16" "harmonic16-light-base16" "harper" "heetch-dark-base16" "heetch-light-base16" "helios-base16" "hemisu-dark-gogh" "hemisu-light-gogh" "highway" "hipster-green" "hivacruz" "homebrew" "hopscotch" "hopscotch256" "horizon-bright-gogh" "horizon-dark-gogh" "horizon-dark-base16" "horizon-light-base16" "humanoid-dark-base16" "humanoid-light-base16" "hurtado" "hybrid" "hybrid-gogh" "hybrid-terminal-sexy" "ic-green-ppl" "ic-orange-ppl" "ir-black-base16" "ir-black" "ibm3270-high-contrast-gogh" "ibm3270-gogh" "ic-green-ppl-gogh" "icy-dark-base16" "iiamblack-terminal-sexy" "insignificato-terminal-sexy" "invisibone-terminal-sexy" "ir-black-gogh" "isotope-base16" "isotope-light-terminal-sexy" "ivory-dark-terminal-sexy" "ivory-light-terminal-sexy" "jwr-dark-terminal-sexy" "jackie-brown" "japanesque" "jason-wryan-terminal-sexy" "jellybeans" "jetbrains-darcula" "jup-gogh" "kanagawa-gogh" "kasugano-terminal-sexy" "kibble" "kimber-base16" "kokuban-gogh" "kolorit" "konsol-s" "lab-fox" "laser" "laserwave-gogh" "later-this-evening" "lavandula" "light-white-terminal-sexy" "liquidcarbon" "liquidcarbontransparent" "liquidcarbontransparentinverse" "london-tube-base16" "londontube-light-terminal-sexy" "lost-woods-terminal-sexy" "low-contrast-terminal-sexy" "lumifoo-terminal-sexy" "lunaria-dark-gogh" "lunaria-eclipse-gogh" "lunaria-light-gogh" "macintosh-base16" "maia-gogh" "man-page" "mar-gogh" "mariana" "marrakesh-base16" "marrakesh-light-terminal-sexy" "mashup-colors-terminal-sexy" "materia-base16" "material" "material-gogh" "material-base16" "material-terminal-sexy" "material-darker-base16" "material-lighter-base16" "material-palenight-base16" "material-vivid-base16" "materialdark" "materialdarker" "materialdesigncolors" "materialocean" "mathias" "matrix-terminal-sexy" "medallion" "mellow-purple-base16" "mexico-light-base16" "mikado-terminal-sexy" "mikazuki-terminal-sexy" "mirage" "misterioso" "mocha-base16" "mocha-light-terminal-sexy" "modusoperandi" "modusvivendi" "molokai" "molokai-gogh" "monalisa" "mono-terminal-sexy" "mono-amber-gogh" "mono-cyan-gogh" "mono-green-gogh" "mono-red-gogh" "mono-theme-terminal-sexy" "mono-white-gogh" "mono-yellow-gogh" "monokai-base16" "monokai-light-terminal-sexy" "monokai-terminal-sexy" "monokai-dark-gogh" "monokai-pro-gogh" "monokai-pro-ristretto-gogh" "monokai-remastered" "monokai-soda" "monokai-vivid" "morada-gogh" "mostly-bright-terminal-sexy" "muse-terminal-sexy" "n0tch2k" "nancy-terminal-sexy" "nature-suede-terminal-sexy" "navy-and-ivory-terminal-sexy" "nebula-base16" "neon" "neon-terminal-sexy" "neon-night-gogh" "neopolitan" "nep-gogh" "neutron" "night3024" "night-owl-gogh" "night-owl-sh-light" "nightlion-v1" "nightlion-v2" "nighty-gogh" "nocturnal-winter" "nova-base16" "novel" "nucolors-terminal-sexy" "nudge-terminal-sexy" "numix-darkest-terminal-sexy" "obsidian" "ocean" "ocean-base16" "ocean-light-terminal-sexy" "ocean-dark-gogh" "oceanicnext" "oceanicmaterial" "oceanicnext-base16" "ollie" "omni-gogh" "one-dark-gogh" "one-half-black-gogh" "one-light-gogh" "one-light-base16" "onedark-base16" "onehalfdark" "onehalflight" "operator-mono-dark" "orangish-terminal-sexy" "outrun-dark-base16" "overnight-slumber" "palenighthc" "palenight-gogh" "pali-gogh" "panda-gogh" "pandora" "panels-terminal-sexy" "papercolor-dark-base16" "papercolor-light-base16" "papercolor-dark-gogh" "papercolor-light-gogh" "paraiso-light-terminal-sexy" "paraiso-dark" "parker-brothers-terminal-sexy" "pasque-base16" "pastel-white-terminal-sexy" "paul-millr-gogh" "paulmillr" "pencildark" "pencillight" "peppermint" "peppermint-gogh" "phd-base16" "phrak1-terminal-sexy" "piatto-light" "pico-base16" "pixiefl-ss-gogh" "pnevma" "poimandres" "poimandres-storm" "pop-base16" "popping-and-locking" "porple-base16" "powershell-gogh" "predawn-gogh" "pretty-and-pastel-terminal-sexy" "pro" "pro-light" "pulp-terminal-sexy" "purple-people-eater-gogh" "purple-rain" "purpledream-base16" "qualia-base16" "railscasts-base16" "railscasts-light-terminal-sexy" "rapture" "rasi-terminal-sexy" "raycast-dark" "raycast-light" "rebecca-base16" "red-alert" "red-phoenix-terminal-sexy" "red-planet" "red-sands" "relaxed" "retro" "rezza-terminal-sexy" "rippedcasts" "rose-pine" "rose-pine-dawn" "rose-pine-moon" "rouge2" "royal" "rydgel-terminal-sexy" "ryuuko" "sos-terminal-sexy" "sagelight-base16" "sakura" "sakura-base16" "sandcastle-base16" "sat-gogh" "scarlet-protocol" "seashel-s" "seafoam-pastel" "sequoia-monochrome" "sequoia-moonlight" "seti" "seti-ui-base16" "sex-colors-terminal-sexy" "shades-of-purple-base16" "shaman" "shapeshifter-base16" "shapeshifter-dark-terminal-sexy" "shapeshifter-light-terminal-sexy" "shel-gogh" "shic-terminal-sexy" "silk-dark-base16" "silk-light-base16" "simple-rainbow-terminal-sexy" "slate" "sleepyhollow" "smyck" "smyck-gogh" "snazzy" "snazzy-gogh" "snazzy-base16" "softserver" "solar-flare-base16" "solar-flare-light-base16" "solarized-dark-terminal-sexy" "solarized-light-terminal-sexy" "solarized-darcula" "solarized-dark-gogh" "solarized-dark-patched" "solarized-dark-higher-contrast" "sonokai-gogh" "spacegray" "spacegray-eighties" "spacegray-eighties-dull" "spacedust" "spacemacs-base16" "spiderman" "splurge-terminal-sexy" "spring" "spring-gogh" "square" "square-gogh" "srcery-gogh" "sublette" "subliminal" "summer-pop-gogh" "summerfruit-dark-base16" "summerfruit-light-base16" "sundried" "swayr-terminal-sexy" "sweet-eliverlara-gogh" "sweet-love-terminal-sexy" "sweet-terminal-gogh" "symfonic" "synth-midnight-terminal-dark-base16" "synth-midnight-terminal-light-base16" "synthwave-gogh" "synthwave-alpha-gogh" "synthwavealpha" "tango-base16" "tango-terminal-sexy" "tango-adapted" "tango-half-adapted" "tangoesque-terminal-sexy" "tartan-terminal-sexy" "teerb" "tender-gogh" "terminal-basic" "terminix-dark-gogh" "teva-terminal-sexy" "thayer-bright" "the-hulk" "tin-gogh" "tinacious-design-dark" "tinacious-design-light" "tokyo-night-gogh" "tokyo-night-light-gogh" "tokyo-night-storm-gogh" "tomorrow" "tomorrow-gogh" "tomorrow-dark-terminal-sexy" "tomorrow-light-terminal-sexy" "tomorrow-night" "tomorrow-night-gogh" "tomorrow-night-blue" "tomorrow-night-blue-gogh" "tomorrow-night-bright" "tomorrow-night-bright-gogh" "tomorrow-night-burns" "tomorrow-night-eighties" "tomorrow-night-eighties-gogh" "toychest" "treehouse" "trim-yer-beard-terminal-sexy" "twilight" "twilight-base16" "twilight-light-terminal-sexy" "ubuntu" "ultradark" "ultraviolent" "underthesea" "unikitty" "unikitty-dark-base16" "unikitty-light-base16" "unikitty-reversible-base16" "unsifted-wheat-terminal-sexy" "ura-gogh" "urple" "vwbug-terminal-sexy" "vacuous2-terminal-sexy" "vag-gogh" "vaughn" "vibrantink" "vice-alt-base16" "vice-dark-base16" "violet-dark" "violet-light" "visiblue-terminal-sexy" "visibone-terminal-sexy" "visibone-alt2-terminal-sexy" "vs-code-dark-plus-gogh" "vs-code-light-plus-gogh" "warmneon" "wez" "whimsy" "wildcherry" "windows10-base16" "windows10-light-base16" "windows95-base16" "windows95-light-base16" "windows-high-contrast-base16" "windows-high-contrast-light-base16" "windows-nt-base16" "windows-nt-light-base16" "wombat" "woodland-base16" "wryan" "wzoreck-gogh" "x-dotshare-terminal-sexy" "x-erosion-terminal-sexy" "xcode-dusk-base16" "yousai-terminal-sexy" "zenburn" "zenburn-base16" "aikofog-terminal-sexy" "arcoiris" "astromouse-terminal-sexy" "ayu" "ayu-light" "carbonfox" "coffee-theme" "cyberpunk" "darkermatrix" "darkmatrix" "darkmoss-base16" "dawnfox" "dayfox" "deep" "dirtysea-base16" "duckbones" "duskfox" "hund-terminal-sexy" "icebergdark" "iceberglight" "idea" "idletoes" "jmbi-terminal-sexy" "jubi" "kanagawabones" "lovelace" "matrix" "midnightinmojave" "neobones-dark" "neobones-light" "nightfox" "nord" "nordfox" "pinky-base16" "primary" "purplepeter" "rebecca" "s3r0-modified-terminal-sexy" "seoulbones-dark" "seoulbones-light" "shadesofpurple" "summercamp-base16" "synthwave" "synthwaveeverything" "tender-base16" "terafox" "theme2-terminal-sexy" "thwump-terminal-sexy" "tlh-terminal-sexy" "tokyonight-day" "tokyonight-moon" "tokyonight-night" "tokyonight-storm" "vimbones" "vulcan-base16" "wilmersdorf" "zenbones" "zenbones-dark" "zenburn-terminal-sexy" "zenburned" "zenwritten-dark" "zenwritten-light")


    while getopts "w" opt; do
        case $opt in
            w) apply_wallpaper=true ;;
            \?) echo "Invalid option: -$OPTARG"
                echo "Usage: pal-apply [-w]"
                return 1 ;;
        esac
    done

    shift $((OPTIND - 1))

    # Select multiple palettes with fzf
    selected_palettes=$(echo "${palettes[@]}" | tr ' ' '\n' | fzf --multi --prompt='Choose palettes: ')

    if [ -z "$selected_palettes" ]; then
        echo "No palettes selected. Exiting."
        return 1
    fi

    # Convert the selected palettes to an array
    selected_palettes=(${(f)selected_palettes})

    selected_images=$(find . -maxdepth 1 -type f \( -iname \*.jpg -o -iname \*.png -o -iname \*.jpeg \) | fzf --multi --prompt='Choose images to modify: ')

    if [ -z "$selected_images" ]; then
        echo "No images selected. Exiting."
        return 1
    fi

    # Loop through selected images
    for image in ${(f)selected_images}; do
        # Render the original image only once
        echo "Rendering original image: $image"
        render "$image"

        # Loop through selected palettes
        for palette in "${selected_palettes[@]}"; do
            # Change the output_image format here
            local output_image="${palette}_$(basename "$image")"
            lutgen -p "$palette" apply "$image" -o "$output_image"
            echo "Modified image saved as $output_image"
            echo "Rendering modified image: $output_image"
            render "$output_image"
        done
    done

    if [ "$apply_wallpaper" = true ]; then
        # Note: Only the last modified image will be set as wallpaper
        echo "Setting the last modified image as wallpaper"
        wal -i "$output_image"
    fi
}
#+end_src
** renderall
#+begin_src shell
renderall() {
    # Set the nullglob option for zsh
    setopt nullglob

    # Loop through jpg and png image files
    for image_file in *.{jpg,png}; do
        # Get the file size in bytes
        file_size_bytes=$(du -b "$image_file" | cut -f1)
        # Convert file size to kilobytes
        file_size_kb=$((file_size_bytes / 1024))

        # Get image dimensions
        dimensions=$(identify -format "%wx%h" "$image_file" 2>/dev/null)

        # Display file information in color in a single line
        # File name in bright cyan, size in yellow, and dimensions in green
        echo -e "\033[1;36m$image_file \033[1;33m[$file_size_kb KB]\033[1;32m [$dimensions]\033[0m"

        # Render the image using 'kitty +kitten icat'
        kitty +kitten icat "$image_file"
    done
}
#+end_src

* define
*REPLACE:*
- keep org level and position

*OVERWRITE:* [x]
*TODO:*
- define must also be able to define new functions

  the modified function is appended at the
  end of this org document so it overwrite the old one if it has the same name,
#+begin_src shell
define () {
    local name=$1
    local def=$(declare -f $name 2>/dev/null)

    if [[ -z "$def" ]]
    then
        echo "$name not found"
        return 1
    fi

    local temp_file_dir="/tmp"
    local temp_file="${temp_file_dir}/${name}.zsh"

    echo "$def" > $temp_file
    nvim $temp_file

    local zshrc_file="${HOME}/Desktop/pulls/dotfiles/.config/zsh/.zshrc.org"

    local start_line=$(grep -n "^* $name" $zshrc_file | cut -d : -f 1)
    if [[ -n "$start_line" ]]
    then
        # Change this line to find the end line of the function's definition
        local end_line=$(grep -n -m 1 -A 1 "^* $name" $zshrc_file | tail -n 1 | cut -d : -f 1)
        if [[ -z "$end_line" ]]
        then
            end_line=$(wc -l < $zshrc_file)
        fi
        sed -i "${start_line},${end_line}d" "$zshrc_file"
    fi

    echo "* $name" >> $zshrc_file
    echo '#+begin_src shell' >> $zshrc_file
    cat $temp_file >> $zshrc_file
    echo '#+end_src' >> $zshrc_file

    rm -vI -f $temp_file

    emacsclient -e "(progn (require 'org) (find-file \"${zshrc_file}\") (org-babel-tangle))"

    update-dotfiles
    exec zsh
}
#+end_src
**ciao

** Delete
Delete the last occurring function from this file.
then ~org-babel-tangle~ then update the ~zsh~ shell
*TODO:*
- work both with ~delete function-name~ || ~delete~
  - delete will delete the last function defined in this org file
#+begin_src shell

#+end_src
*** v2
#+begin_src shell
delete() {
	local name=$1
	local zshrc_file="${HOME}/Desktop/pulls/dotfiles/.config/zsh/.zshrc.org"

	# If no function name is given, get the name of the last function defined
	if [[ -z "$name" ]]; then
		name=$(grep -oP "^* \K\w+" $zshrc_file | tail -n 1)
	fi

	# Get the last start line
	local start_line=$(grep -n "^* $name" $zshrc_file | cut -d : -f 1 | tail -n 1)

	if [[ -n "$start_line" ]]
	then
		# Get lines for "#+end_src" occurring after the function start line
		local end_lines=$(awk -v start="$start_line" 'NR >= start && /#\+end_src/ {print NR}' "$zshrc_file")
		# Select the first of these as the end line
		local end_line=$(echo "$end_lines" | head -n 1)

		# If no end line found, set it to last line of file
		[[ -z "$end_line" ]] && end_line=$(wc -l < "$zshrc_file")

		# Deletes the function from the zshrc file
		sed -i "${start_line},${end_line}d" "$zshrc_file"
	else
		echo "Function $name not found in $zshrc_file"
		return 1
	fi

	# Unsets the function from the current session
	unset -f $name

	# Tangle org file
	emacsclient -e "(progn (require 'org) (find-file \"${zshrc_file}\") (org-babel-tangle))"

	update-dotfiles
	exec zsh
}
#+end_src

* Typetune
** Typetune-new-theme
#+begin_src shell
typetune-new-theme () {
    destination_directory_base="$HOME/xos/typetune/switches"
    file_types=("ogg" "wav")

    ls $HOME/.local/share/osu-stable/Skins | fzf -m | while IFS= read -r theme_name; do
        if [ -z "$theme_name" ]
        then
            echo "No themes chosen"
            return 1
        fi

        destination_directory="$destination_directory_base/$theme_name"
        mkdir -p "$destination_directory"

        for file_type in "${file_types[@]}"; do
            cp -iv "$HOME/.local/share/osu-stable/Skins/$theme_name/key-delete.${file_type}" \
                   "$HOME/.local/share/osu-stable/Skins/$theme_name/key-press-1.${file_type}" \
                   "$HOME/.local/share/osu-stable/Skins/$theme_name/key-press-2.${file_type}" \
                   "$HOME/.local/share/osu-stable/Skins/$theme_name/key-press-3.${file_type}" \
                   "$HOME/.local/share/osu-stable/Skins/$theme_name/key-press-4.${file_type}" \
                   "$HOME/.local/share/osu-stable/Skins/$theme_name/key-press.${file_type}" \
                   "$destination_directory" 2>/dev/null
        done
    done
}
#+end_src
** Typetune-get-sounds
#+begin_src shell
function typetune-get-sounds() {
    # Specify the source directory
    local source_dir=~/.local/share/osu-stable/Skins/

    # Use rsync to recursively copy .ogg and .wav files
    sync -avm --include='*.wav' --include='*.ogg' -f 'hide,! */' "$source_dir" .
}
#+end_src
* Brutepaste
simulating keybord input to type copied "force paste"
#+begin_src shell
brutepaste() {
    current=$(xkb-switch -p)
    setxkbmap us -option caps:none
    xdotool type "$(xclip -o)" && sleep 1
    trap "setxkbmap $current -option caps:none" 0
}
#+end_src

* THEME
*TODO:*
- set a specific wallpaper per theme [x]
- set also nvim theme []
- maybe gtk too [x]
- change x cursor [x]
- xmobar change colors in real time []
- Doom emacs too maybe ? just for hardcoded themes not pywal []
- specific bar theme []
#+begin_src shell
theme() {
  local themes=(
    "palenight"
    "dracula"
    "catppuccin"
    "pywal"
    "rosepine"
    "oxocarbon"
  )

  # Themes that require pkill picom
  local pkill_themes=(
    "oxocarbon"
    "palenight"
    # Add more themes as necessary
  )

  # Themes that require picom
  local picom_themes=(
    "pywal"
    "dracula"
    # Add more themes as necessary
  )

  local selected_theme

  if [[ -z $1 ]]; then
    selected_theme=$(printf '%s\n' "${themes[@]}" | splittedfzf)
  else
    selected_theme=$1
  fi

  local no_random_flag=$2

  # Save the selected theme name to a file
  echo $selected_theme > ~/xos/theme/.theme

  # Update the theme
  fzf_theme $selected_theme
  nvim_theme $selected_theme
  lxappearance_theme $selected_theme
  dmenu_theme $selected_theme
  # gtk_theme $selected_theme

  # If the theme is pywal and no_random_flag is set, do not change wallpaper
  if [[ $selected_theme == "pywal" && $no_random_flag == "--no-random" ]]; then
    # Do nothing
    :
  else
    wallpaper_theme $selected_theme
  fi

  # Check if the selected theme is in the pkill_themes array and pkill picom if it is
  if [[ " ${pkill_themes[@]} " =~ " ${selected_theme} " ]]; then
    pkill picom || true
  fi

  # Check if the selected theme is in the picom_themes array and start picom if it is
  # But only if it is not already running
  if [[ " ${picom_themes[@]} " =~ " ${selected_theme} " ]]; then
    if ! pgrep -x "picom" > /dev/null; then
      picom & disown
    fi
  fi

  # Update the kitty theme if it is not default
  if [ "$selected_theme" != "default" ]; then
    kitty +kitten themes --reload-in=all $selected_theme
  fi
}
#+end_src
** fzf_theme
#+begin_src shell
fzf_theme() {
  local selected_theme=$1

  case $selected_theme in
    "palenight")
      export FZF_DEFAULT_OPTS="\
      --color=bg+:#292D3E,bg:#292D3E,spinner:#C792EA,hl:#82AAFF \
      --color=fg:#EEFFFF,header:#82AAFF,info:#89DDFF,pointer:#C792EA \
      --color=marker:#C792EA,fg+:#EEFFFF,prompt:#89DDFF,hl+:#82AAFF"
      ;;
    "dracula")
      export FZF_DEFAULT_OPTS="\
      --color=bg+:#282A36,bg:#282A36,spinner:#8BE9FD,hl:#ff79c6 \
      --color=fg:#f8f8f2,header:#BD93F9,info:#8be9fd,pointer:#50fa7b \
      --color=marker:#50fa7b,fg+:#f8f8f2,prompt:#8be9fd,hl+:#ff79c6"
      ;;
    "catppuccin")
      export FZF_DEFAULT_OPTS="\
      --color=bg+:#101213,bg:#101213,spinner:#f5e0dc,hl:#f38ba8 \
      --color=fg:#cdd6f4,header:#f38ba8,info:#cba6f7,pointer:#f5e0dc \
      --color=marker:#f5e0dc,fg+:#cdd6f4,prompt:#cba6f7,hl+:#f38ba8"
      ;;
    "oxocarbon")
      export FZF_DEFAULT_OPTS="\
      --color=bg+:#161616,bg:#161616,spinner:#FFE585,hl:#f38ba8 \
      --color=fg:#cdd6f4,header:#f38ba8,info:#33B1FF,pointer:#FF7EB6 \
      --color=marker:#f5e0dc,fg+:#cdd6f4,prompt:#cba6f7,hl+:#f38ba8"
      ;;
    "rosepine")
      export FZF_DEFAULT_OPTS="\
      --color=bg+:#191724,bg:#191724,spinner:#9CCFD8,hl:#EB6F92 \
      --color=fg:#cdd6f4,header:#f38ba8,info:#EABBB9,pointer:#F6C177 \
      --color=marker:#f5e0dc,fg+:#cdd6f4,prompt:#cba6f7,hl+:#C4A7E7"
      ;;
    "adventure")
      export FZF_DEFAULT_OPTS="\
      --color=bg+:#191724,bg:#191724,spinner:#9CCFD8,hl:#EB6F92 \
      --color=fg:#cdd6f4,header:#f38ba8,info:#EABBB9,pointer:#F6C177 \
      --color=marker:#f5e0dc,fg+:#cdd6f4,prompt:#cba6f7,hl+:#C4A7E7"
      ;;
    "pywal")
      export FZF_DEFAULT_OPTS="--color=16"
      ;;
    ,*)
      echo "Unknown theme. Please specify one of: PALENIGHT, DRACULA, CATPPUCCIN, DEFAULT."
      ;;
  esac
}
#+end_src
** Lxappearance_theme
#+begin_src shell
lxappearance_theme () {
    local selected_theme
    if [[ -z $1 ]]
    then
        echo "Please specify a theme"
    else
        selected_theme=$1
        case $selected_theme in
            ("palenight") gtk_theme="palenight"
                icon_theme="palenight"
                cursor_theme="palenight" ;;
            ("dracula") gtk_theme="Dracula"
                icon_theme="Dracula"
                cursor_theme="Dracula-cursors"  ;;
            ("catppuccin") gtk_theme="Catppuccin-Mocha-Standard-Mauve-Dark"
                icon_theme="Papirus-Dark"
                cursor_theme="Catppuccin-Mocha-Dark"  ;;
            ("oxocarbon") gtk_theme="SomeGtkTheme"
                icon_theme="candy-icons"
                cursor_theme="adwaita"  ;;
            ("rosepine") gtk_theme="rose-pine-gtk"
                icon_theme="candy-icons"
                cursor_theme="adwaita"  ;;
            ("pywal") gtk_theme="pywall" # can be set to "wal" for trasparent bg
                icon_theme="Papirus"
                cursor_theme="adwaita"  ;;
            (*) echo "Unknown theme. Please specify one of: palenight, dracula, catppuccin, oxocarbon, rosepine, pywal."
                return ;;
        esac

        # Update GTK-3.0 settings
        sed -i "s/^gtk-theme-name=.*$/gtk-theme-name=$gtk_theme/" ~/.config/gtk-3.0/settings.ini
        sed -i "s/^gtk-icon-theme-name=.*$/gtk-icon-theme-name=$icon_theme/" ~/.config/gtk-3.0/settings.ini
        sed -i "s/^gtk-cursor-theme-name=.*$/gtk-cursor-theme-name=$cursor_theme/" ~/.config/gtk-3.0/settings.ini

        # Update GTK-2.0 settings
        sed -i "s/^gtk-theme-name=.*$/gtk-theme-name=\"$gtk_theme\"/" ~/.gtkrc-2.0
        sed -i "s/^gtk-icon-theme-name=.*$/gtk-icon-theme-name=\"$icon_theme\"/" ~/.gtkrc-2.0
        sed -i "s/^gtk-cursor-theme-name=.*$/gtk-cursor-theme-name=\"$cursor_theme\"/" ~/.gtkrc-2.0
    fi
}
#+end_src
** Wallpaper_theme
#+begin_src shell
wallpaper_theme () {
	local selected_theme
	local wallpapers_dir="$HOME/xos/wallpapers/static"
	if [[ -z $1 ]]
	then
		echo "Please specify a theme"
	else
		selected_theme=$1
		case $selected_theme in
			("palenight") wallpaper="$wallpapers_dir/distro/iarch/material-palenight-base16_iarch.png"  ;;
			("dracula") wallpaper="$wallpapers_dir/ship/Ship.png"  ;;
			("catppuccin") wallpaper="$wallpapers_dir/catppuccin/waves.png"  ;;
			("oxocarbon") wallpaper="$wallpapers_dir/oxocarbon/wallpaper.jpg"  ;;
			("rosepine") wallpaper="$wallpapers_dir/rose/wallpaper.jpg"  ;;
			("pywal")
				wallpaper=$(find $wallpapers_dir -type f | shuf -n 1)
				wal -i "$wallpaper"
				;;
			(*) echo "Unknown theme. Please specify one of: palenight, dracula, catppuccin, oxocarbon, rosepine, pywal."
				return ;;
		esac
		if [[ $selected_theme != "pywal" ]]; then
			feh --bg-scale "$wallpaper"
		fi
		echo "Wallpaper updated for $selected_theme theme"
	fi
}
#+end_src
** Nvim_theme
*TODO*
- it changes the file correctly but nvchad dont change non interactevly
#+begin_src shell
nvim_theme () {
	local selected_theme
	if [[ -z $1 ]]
	then
		echo "Please specify a theme"
	else
		selected_theme=$1
		case $selected_theme in
			("palenight") nvim_theme="palenight"  ;;
			("dracula") nvim_theme="chadracula"  ;;
			("catppuccin") nvim_theme="catppuccin"  ;;
			("oxocarbon") nvim_theme="oxocarbon"  ;;
			("rosepine") nvim_theme="rosepine"  ;;
			("pywal") nvim_theme="pywal"  ;;
			(*) echo "Unknown theme. Please specify one of: palenight, dracula, catppuccin, oxocarbon, rosepine, pywal."
				return ;;
		esac
		sed -i "s/^  theme = .*$/  theme = \"$nvim_theme\",/" ~/.config/nvim/lua/custom/chadrc.lua
		echo ":wq" | nvim -Es ~/.config/nvim/lua/custom/chadrc.lua
		echo "Neovim theme updated to $selected_theme"
	fi
}
#+end_src
** Dmenu_theme
*TODO:*
- make pywal default to base theme [x]
- change position based on theme [x]
  - currently position change only if emacs is focused in =~/.local/bin/dm-run=
#+begin_src shell
dmenu_theme() {
  local selected_theme

  if [ -n "$1" ]; then
    selected_theme=$1
  elif [ -f ~/xos/theme/.theme ]; then
    selected_theme=$(cat ~/xos/theme/.theme)
  else
    echo "No theme specified and no default theme found at ~/xos/theme/.theme"
    return 1
  fi

  case $selected_theme in
    "palenight")
      DMENU_COLORS="-nb #292D3E -nf #EEFFFF -sb #C792EA -sf #82AAFF"
      DMENU_POSITION="-X 0"
      DMENU_Y_POSITION="-Y 0"
      ;;
    "dracula")
      DMENU_COLORS="-nb #282A36 -nf #f8f8f2 -sb #8BE9FD -sf #ff79c6"
      DMENU_POSITION="-X 0"
      DMENU_Y_POSITION="-Y 0"
      ;;
    "catppuccin")
      DMENU_COLORS="-nb #101213 -nf #cdd6f4 -sb #f5e0dc -sf #f38ba8"
      DMENU_POSITION="-X 1239"
      DMENU_Y_POSITION="-Y 500"
      ;;
    "oxocarbon")
      DMENU_COLORS="-nb #161616 -nf #cdd6f4 -sb #FFE585 -sf #f38ba8"
      DMENU_POSITION="-X 0"
      DMENU_Y_POSITION="-Y 0"
      ;;
    "rosepine")
      DMENU_COLORS="-nb #191724 -nf #cdd6f4 -sb #9CCFD8 -sf #EB6F92"
      DMENU_POSITION="-X 1239"
      DMENU_Y_POSITION="-Y 500"
      ;;
    "pywal")
      # Default to original purple theme for the border, use neutral colors for the rest # TODO use wal colors
      DMENU_COLORS="-nb #282a36 -nf #f8f8f2 -sb #BD93F9 -sf #000000"
      DMENU_POSITION="-X 0"
      DMENU_Y_POSITION="-Y 0"
      ;;
    *)
      echo "Unknown theme. Please specify one of: palenight, dracula, catppuccin, oxocarbon, rosepine, pywal."
      return 1
      ;;
  esac

  # Save dmenu colors and positions to files for use in other scripts
  echo "${DMENU_COLORS[@]}" > ~/xos/theme/.dmenu_theme
  echo "${DMENU_POSITION}" > ~/xos/theme/.dmenu_position
  echo "${DMENU_Y_POSITION}" > ~/xos/theme/.dmenu_y_position
}
#+end_src
** Xmonad_theme
#+begin_src shell

function xmonad_theme() {
  local selected_theme
  if [[ -z $1 ]]
  then
      echo "Please specify a theme"
  else
      selected_theme=$(echo "$1" | awk '{print tolower($0)}')
      filepath="$HOME/.config/xmonad/xmonad.hs"
      available_themes="doomone dracula gruvboxdark monokaipro nord oceanicnext palenight solarizeddark solarizedlight tomorrownight wal oxoterm mocha"
      correct_case="DoomOne Dracula GruvboxDark MonokaiPro Nord OceanicNext Palenight SolarizedDark SolarizedLight TomorrowNight Wal Oxoterm Mocha"

      if [[ $available_themes =~ (^|[[:space:]])"$selected_theme"($|[[:space:]]) ]]; then
          for available_theme in $available_themes; do
              correct_case_theme=$(echo "${correct_case}" | awk -v idx=$(expr index "$available_themes" $available_theme) '{print $idx}')
              if grep -q "import Colors.${correct_case_theme}" "${filepath}"; then
                  sed -i "s/^import Colors.${correct_case_theme}/-- import Colors.${correct_case_theme}/" "${filepath}"
              fi
              if [[ "${available_theme}" == "${selected_theme}" ]]; then
                  sed -i "s/^-- import Colors.${correct_case_theme}/import Colors.${correct_case_theme}/" "${filepath}"
              fi
          done
          xmonad --restart
      else
          echo "Invalid theme: ${selected_theme}"
          echo "Valid themes are: ${available_themes}"
          return 1
      fi
  fi
}

#+end_src

#+RESULTS:

** Doom_theme
#+begin_src shell
doom_theme() {
  local selected_theme

  if [[ -z $1 ]]; then
    echo "Please specify a theme"
  else
    selected_theme=$1
    case $selected_theme in
      "palenight") doom_theme="doom-palenight"  ;;
      "dracula") doom_theme="doom-dracula"  ;;
      "catppuccin") doom_theme="catppuccin"  ;;
      "oxocarbon") doom_theme="doom-palenight"  ;;
      "rosepine") doom_theme="doom-rosepine"  ;;
      "pywal") doom_theme="doom-one"  ;;
      *)
        echo "Unknown theme. Please specify one of: palenight, dracula, catppuccin, oxocarbon, rosepine, pywal."
        return ;;
    esac

    # Change the theme in the Doom Emacs configuration file
    sed -i "s/^  (setq doom-theme '.*$/  (setq doom-theme '$doom_theme')/" ~/.doom.d/config.el

    # Refresh Doom Emacs configuration
    \emacs --batch -l ~/.emacs.d/init.el --eval="(doom/reload)"

    echo "Doom Emacs theme updated to $doom_theme"
  fi
}
#+end_srca
** fzf-resurrect
#+begin_src shell
if [ -f ~/xos/theme/.theme ]; then
  fzf_theme $(cat ~/xos/theme/.theme)
fi
#+end_src
* Typetune
#+begin_src shell
typetune() {
    FULL_PATH=$(realpath ~/xos/typetune/typetune.py)
    TYPETUNE_PID=$(pgrep -f "python3 ${FULL_PATH}")
    if [[ -z "$TYPETUNE_PID" ]]; then
        if [[ "$1" == "-off" ]]; then
            echo "Typetune is already off."
        else
            echo "Starting Typetune..."
            nohup python3 $FULL_PATH &
        fi
    else
        if [[ "$1" == "-on" ]]; then
            echo "Typetune is already on."
        else
            echo "Stopping Typetune..."
            kill -9 $TYPETUNE_PID
        fi
    fi
}
#+end_src
