#+title: .zshrc
#+PROPERTY: header-args :tangle .zshrc
#+auto_tangle: t

* TODO
true keychord inside zsh
whichkey inside zsh
evil keybinds to split panes (maybe inside kitty conf)
**  easy
kyeinind to fzf aur packages

* PATH
#+begin_src shell
#TODO make it look cooler
function path() {
  local dir_list=$(echo $PATH | sed "s/:/\\n/g")
  printf "EnvPath([\n" && printf "'%s',\n" $dir_list | sed "s|^ |/|; s|^|  |" && printf "])\n"
}

#+end_src
** exports
#+begin_src shell
export PATH="$PATH:$HOME/.config/emacs/bin"
export PATH="$PATH:$HOME/.cargo/bin"

 if [[ -n $SSH_CONNECTION ]]; then
   export EDITOR='nvim'
 else
   export EDITOR='nvim'
 fi
#+end_src
*** rofi
#+begin_src shell
export ROFI_THEME="/home/l/.cache/wal/colors-rofi-dark.rasi"
#+end_src
** source
*** env-secrets
where you keep api keys
#+begin_src shell
source ~/xos/.env_secrets
#+end_src
* plugins
**** syntax-highlighting
#+begin_src shell
source /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 2>/dev/null # PACMAN path
# source $HOME/.config/zsh/plug/fzf-keybindings.plugins.zsh
#+end_src
**** pywal
#+begin_src shell
# source ~/.cache/wal/colors.sh
#+end_src
* DEFAULT
** Fallback-prompt
#+begin_src shell
#Enable colors and change fallback prompt:
autoload -U colors && colors

# PS1="%B%{$fg[red]%}[%{$fg[yellow]%}%n%{$fg[green]%}@%{$fg[blue]%}%M %{$fg[magenta]%}%~%{$fg[red]%}]%{$reset_color%}$%b "
PS1="%{$fg[red]%}[%{$fg_bold[white]%}ERROR%{$fg[red]%}]%{$reset_color%} "
#+end_src
** Fetch-plugins
#+begin_src shell
# Fetch all plugins in dir
plugins=(`echo $(ls $ZSH/plugins | sed -z 's/\n/ /g')`)
#+end_src
** Auto-tab-complete
#+begin_src shell
autoload -U compinit
zstyle ':completion:*' menu select
zmodload zsh/complist
#compinit _comp_options+=(globdots)		# Include hidden files.
#+end_src
** evil-tab
#+begin_src shell
# Use vim keys in tab complete menu:
bindkey -M menuselect 'h' vi-backward-char
bindkey -M menuselect 'k' vi-up-line-or-history
bindkey -M menuselect 'l' vi-forward-char
bindkey -M menuselect 'j' vi-down-line-or-history
bindkey -v '^?' backward-delete-char

bindkey -s '^r' 'lfcd\n'
bindkey -s '^e' 'pcmanfm\n'
#+end_src


** xxx
#+begin_src shell
# below opens a new terminal in current dir
# case "$TERM" in (rxvt|rxvt-*|st|st-*|*xterm*|(dt|k|E)term)
#     local term_title () { print -n "\e]0;${(j: :q)@}\a" }
#     precmd () {
#       local DIR="$(print -P '[%c]')"
#       term_title "$DIR" "st"
#     }
#     preexec () {
#       local DIR="$(print -P '[%c]%#')"
#       local CMD="${(j:\n:)${(f)1}}"
#       #term_title "$DIR" "$CMD" use this if you want directory in command, below only prints program name
# 	  term_title "$CMD"
#     }
#   ;;
# esac

#Set bookmarks dir
# To add any bookmark, use command below without quotes:
# bm 'bookmarkdir' '@bookmarkname' OR bm @bookmarkname to bookmark current directory
[[ -d "$ZSHCFG/bookmarks" ]] && export CDPATH=".:$ZSHCFG/bookmarks:/" \
	&& alias jmp="cd -P"

setopt autocd
# change below theme if using oh-my-zsh
#ZSH_THEME=""
HISTSIZE=10000
SAVEHIST=10000
setopt appendhistory
#+end_src
* Cursor
#+begin_src shell
# Change cursor shape for different vi modes.
function zle-keymap-select {
  if [[ ${KEYMAP} == vicmd ]] ||
     [[ $1 = 'block' ]]; then
    echo -ne '\e[1 q'
  elif [[ ${KEYMAP} == main ]] ||
       [[ ${KEYMAP} == viins ]] ||
       [[ ${KEYMAP} = '' ]] ||
       [[ $1 = 'beam' ]]; then
    echo -ne '\e[5 q'
  fi
}
function _set_cursor() {
    if [[ $TMUX = '' ]]; then
      echo -ne $1
    else
      echo -ne "\ePtmux;\e\e$1\e\\"
    fi
}
#+end_src
* Load aliases
#+begin_src shell
# Load aliases
[ -f "$ZSHCFG/aliasrc" ] && source "$ZSHCFG/aliasrc"

# Note that in different distro or installation way below source files need to be changed, they are usually in ~/.zsh/
source "$ZSHCFG/OMZ/oh-my-zsh.sh"
source /usr/share/zsh/plugins/fast-syntax-highlighting/fast-syntax-highlighting.plugin.zsh 2>/dev/null
#+end_src
* Evil-mode
#+begin_src shell
# vi mode
bindkey -v
export KEYTIMEOUT=1
export GPG_TTY=$(tty)
if [ ! -z $BM_DIR ]; then
    cd -P $BM_DIR &&
    export BM_DIR=""
fi

# Below to change autosuggestion options
# ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE="fg=blue,bg=#292D3E,bold,underline"	# To get colored completion text
bindkey '^[[Z' autosuggest-accept   # shift tab to accept ghost text
ZSH_AUTOSUGGEST_CLEAR_WIDGETS+=(buffer-empty bracketed-paste accept-line push-line-or-edit)
ZSH_AUTOSUGGEST_STRATEGY=(history completion)
ZSH_AUTOSUGGEST_USE_ASYNC=true

export LESS_TERMCAP_mb=$(tput bold; tput setaf 39)
export LESS_TERMCAP_md=$(tput bold; tput setaf 45)
export LESS_TERMCAP_me=$(tput sgr0)


#+end_src
* MDL
Music download
#+begin_src shell
function mdl() {
    local original_dir=$(pwd)
    cd ~/Music

    for url in "$@"; do
        yt-dlp --extract-audio --audio-format mp3 -i --ignore-config  --no-part --no-warnings -w -c -R 15 --output "%(title)s.%(ext)s" "$url"
    done

    cd "$original_dir"
}
#+end_src
* QUICK-ACCESS
** userchrome
#+begin_src shell
userchrome() {
  c ~/.mozilla/firefox/exnoy41o.default-release/chrome
}
#+end_src
** desktop-apps
#+begin_src shell
function desktop-apps() {
    c ~/.local/share/applications
}
#+end_src
* SHELL
**  image-map
Define a mapping between directory names and image files
custom images based on the enviroment for a more interactive shell
#+begin_src shell
declare -A image_map=(
  # ["rust"]="$HOME/Desktop/xos/xicons/rust.png"
  ["rust"]="$HOME/Desktop/xos/xicons/3.png"
  ["doom"]="$HOME/.doom.d"
  ["lua"]="$HOME/Desktop/xos/xicons/lua.png"
  ["bash"]="$HOME/Desktop/xos/xicons/bash.png"
  ["c++"]="$HOME/Desktop/xos/xicons/cpp.png"
  ["c"]="$HOME/Desktop/xos/xicons/c.png"
  ["haskell"]="$HOME/Desktop/xos/xassets/haskell.png"
  ["python"]="$HOME/Desktop/xos/xassets/python.png"
  ["test"]="$HOME/Desktop/xos/xassets/test.png"
  [".doom.d"]="$HOME/Desktop/xos/xicons/emacs.png"
  ["emacs"]="$HOME/Desktop/xos/xicons/emacs.png"
  ["doom"]="$HOME/Desktop/xos/xicons/emacs.png"
  ["xwal"]="$HOME/Desktop/xos/xicons/xwal.png"
  ["nix"]="$HOME/Desktop/xos/xicons/nix256x256.png"
  ["go"]="$HOME/Desktop/xos/xicons/go.png"
  ["debian"]="$HOME/Desktop/xos/xicons/debian.png"
  ["head"]="$HOME/Desktop/xos/xicons/head.png"
  ["docker"]="$HOME/Desktop/xos/xicons/docker.png"
  ["web"]="$HOME/Desktop/xos/xicons/md.png"
  ["react"]="$HOME/Desktop/xos/xicons/react256x256.png"
  ["cutefish"]="$HOME/Desktop/xos/xicons/cutefish.png"
  ["awesome"]="$HOME/Desktop/xos/xicons/awesome.png"
  ["xos"]="$HOME/Desktop/xos/xicons/xos.png"
 # ["ai"]="$HOME/Desktop/xos/xicons/head.png"
  ["deepin"]="$HOME/Desktop/xos/xicons/deepin.png"
  ["welcome"]="$HOME/Desktop/xos/xicons/weloce.png"
 ["default"]="$HOME/Desktop/xos/xicons/default.png"
)

#+end_src

** display_image
chpwd dependency
#+begin_src shell
function display_image() {
  local image_path="${image_map[$1]}"
  if [[ -z "$image_path" ]]; then
    image_path="${image_map["default"]}"
  fi
  if [[ -f "$image_path" ]]; then
    kitty +kitten icat "$image_path"
  fi
}

#+end_src
** chpwd
#+begin_src shell
function chpwd() {
  local path_parts=("${(@s:/:)PWD}") # Split the current path into an array
  local dir=""
  for part in "${path_parts[@]}"; do
    if [[ -n "${image_map[$part]}" ]]; then
      dir="$part"
    fi
  done

  if [[ -n "$dir" ]]; then
    display_image "$dir"
  else
    display_image "default"
  fi
}

chpwd # run once
#+end_src

* DEV-TOOLS
** diffrun
DIFF RUN :
monitor a directory for changes, then automaticly run any command
#+begin_src shell
#HACK custo function and aliases should work
diffrun() {
        [ -z "$1" ] && { echo "Usage: drun <command> [file/directory]"; return 1; }
        local cmd="$1"
        local target="${2:-$PWD}"
        [ ! -e "$target" ] && { echo "Error: File or directory '$target' not found."; return 1; }
        echo "Monitoring size of '$target' for changes..."
        local prev_size=$(du -sb "$target" | awk '{print $1}')
        while sleep 1; do
            local size=$(du -sb "$target" | awk '{print $1}')
            if [ "$prev_size" -ne "$size" ]; then
            prev_size="$size"
            zsh -c $cmd
            fi
        done
    }
#+end_src
** t
better touch
#+begin_src shell
function t() {
    if [[ $# -eq 0 ]]; then
        echo "Usage: t <filename>"
        return 1
    fi

    # Get file extension
    local ext="${1##*.}"

    # Define templates for each file type
    local template=""
    case "$ext" in
        "cpp")
            template="#include <iostream>

using namespace std;

int main() {
    // your code goes here
    return 0;
}"
            ;;
        "html")
            template='<!DOCTYPE html>
<html>
<head>
    <title>Title</title>
</head>
<body>

    <!-- your code goes here -->

</body>
</html>'
            ;;
        "py")
            template="#!/usr/bin/env python3

# your code goes here"
            ;;
        "sh")
            template="#!/bin/bash

# your code goes here"
            ;;
        "lua")
            template="-- your code goes here"
            ;;
        "rs")
            template="fn main() {
    // your code goes here
}"
            ;;
        "go")
            template='package main

import "fmt"

func main() {
    // your code goes here
}'
            ;;
        "zig")
            template='const std = @import("std");

pub fn main() !void {
    // your code goes here
}'
            ;;
        "hs")
            template="main = do
    -- your code goes here
    return ()"
            ;;
        *)
            echo "Unsupported file type: $ext"
            return 1
            ;;
    esac

    # Generate file with the template (if available)
    if [[ -n "$template" ]]; then
        echo "$template" > "$1"
    else
        touch "$1"
    fi
}










#+end_src
**** bin
***** hex
i dont remember how to use it
#+begin_src shell

function hex() {
    # Get a list of actual binary files in the /usr/bin directory
    local binaries=( $(find /usr/bin -type f -executable -not -name "*.so*" -exec file -i {} \; | grep "charset=binary" | cut -d ":" -f 1) )

    # Prompt the user to select a binary file
    PS3="Select a binary to disassemble: "
    select binfile in "${binaries[@]}"; do
        if [[ -n "$binfile" ]]; then
            # Prompt the user to enter the objdump command
            read -p "Enter objdump command to disassemble $binfile: " objcmd

            # Call the user-specified objdump command on the selected binary file
            $objcmd "$binfile" | less
            break
        else
            echo "Invalid option. Please select a valid binary file."
        fi
    done
}

#+end_src
**** web-apps
***** package-web-app
package a website in a desktop app
"package-web-app https://github.com"
#+begin_src shell

function package-web-app() {
  if [ "$#" -ne 1 ]; then
    echo "Usage: xapp <url>"
    return 1
  fi

  local url="$1"
  local app_name="$(echo ${url} | sed -E 's/.*\:\/\/([^\/]+)(.*)/\1/')"

  nativefier --name "${app_name}" "${url}" --single-instance && c
  echo "Desktop app for ${url} has been created in the current directory."
}

#+end_src
**** lazytest
Usefull when you have a folder full of scripts to test.
#+begin_src shell

function lazytest() {
  # Find all Lua and Python files in the current directory
  files=()
  while IFS= read -r -d $'\0' file; do
    files+=("$file")
  done < <(find . -maxdepth 1 -type f \( -iname "*.lua" -o -iname "*.py" \) -print0)

  run_sequentially "${files[@]}"
}

#+end_src
***** run-sequentially
#+begin_src shell

function run_sequentially() {
  local files=("$@")

  for file in "${files[@]}"; do
    echo "Running $file"

    case "${file##*.}" in
      lua)
        interpreter="lua"
        ;;
      py)
        interpreter="python3"
        ;;
      sh)
        interpreter="bash"
        ;;
      *)
        echo "Unsupported file extension for $file"
        continue
        ;;
    esac

    $interpreter "$file" & # Run the script in the background
    wait $!               # Wait for the background process to finish
  done
}

#+end_src
**** meson
***** mesosbu
#+begin_src shell

# TODO
#dont wipe the first time
function mesosbu() {
  sudo meson setup --wipe build && sudo meson setup --buildtype=release . build && sudo ninja -C build/ && sudo ninja -C build install
}

#+end_src
**** next
#+begin_src shell

next() {
  npx create-next-app "$1"
}
# TODO NEXT-BUILD

#+end_src
**** COMPILE
***** xcompile
#FIXME not working when tangled from here ?
#+begin_src shell

# xcompile() {
#   # Use fzf to select a file to compile
#   filename=$(find . -type f \( -name "*.c" -o -name "*.cpp" -o -name "*.py" -o -name "*.lua" \) | fzf --preview 'bat --color=always {}')

#   # Check if a file was selected
#   if [ -n "$filename" ]
#   then
#     # Create directory if it doesn't exist
#     dir="xcompiled"
#     if [ ! -d "$dir" ]
#     then
#         mkdir "$dir"
#     fi

#     # Move file to the generated directory
#     mv "$filename" "$dir"

#     # Compile and execute the file inside the generated directory
#     cd "$dir"
#     if [[ $filename == *.c ]]
#     then
#         gcc "$filename" -o "${filename%.*}"
#         "./${filename%.*}"
#     elif [[ $filename == *.cpp ]]
#     then
#         g++ "$filename" -o "${filename%.*}"
#         "./${filename%.*}"
#     elif [[ $filename == *.py ]]
#     then
#         python3 "$filename"
#     elif [[ $filename == *.lua ]]
#     then
#         lua "$filename"
#     else
#         echo "Invalid file extension. Please provide a C, C++, Python, or Lua file."
#     fi
#   fi
# }

#+end_src
***** TODO gtk+

#+begin_src shell
#gcc -o simple simple.c `pkg-config --libs --cflags gtk+-2.0`

#+end_src
***** core function
#+begin_src shell

function compile() {
    if [[ -z "$1" ]]; then
        echo "Usage: runc <file>"
        return 1
    fi

    if [[ "${1##*.}" == "c" ]]; then
        gcc -Wall -Wextra -Wpedantic -std=c99 -O2 -o "${1%.*}" "$1" && "./${1%.*}"
    elif [[ "${1##*.}" == "cpp" ]]; then
        g++ -Wall -Wextra -Wpedantic -std=c++17 -O2 -o "${1%.*}" "$1" && "./${1%.*}"
    else
        echo "Error: Unsupported file type"
        return 1
    fi
}

#+end_src
**** pull-website
#+begin_src shell
pull-website() {
  wget --recursive --no-clobber --page-requisites --html-extension --convert-links --restrict-file-names=windows --no-parent $1
}
#+end_src

* BASICS
** screenshot
#+begin_src shell
function screenshot() {
  # Capture screenshot and save it to a temporary file
  local tmp_file="/tmp/screenshot.png"
  maim -s "$tmp_file"

  # Check if the screenshot was captured successfully
  if [ -f "$tmp_file" ]; then
    # Copy the screenshot to the clipboard
    xclip -selection clipboard -t image/png -i "$tmp_file"

    echo "Screenshot captured and copied to clipboard."
  else
    echo "Error capturing the screenshot."
  fi
}
#+end_src
** xshellrp
i lost the config file :)
#+begin_src shell
# FIXME
function xshellrp() {
  xshellrp --config ~/.config/linux-discord-rich-presencerc &&
}
#+end_src
** commons
*** xup
#+begin_src shell
function xup() {
  chmod +x "$1" && c
}
#+end_src
*** xdown
#+begin_src shell
function xdown() {
  chmod -x "$1" && c
}
#+end_src
*** hown
#+begin_src shell
function hown() {
    for file in $@
    do
        cp $file ~/.local/bin/
    done
}
#+end_src
** file-extraction
*** ex
exctract anything
#+begin_src shell
function ex()
{
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xjf $1   ;;
      *.tar.gz)    tar xzf $1   ;;
      *.tar.xz)    tar xJf $1   ;;
      *.bz2)       bunzip2 $1   ;;
      *.rar)       unrar x $1     ;;
      *.gz)        gunzip $1    ;;
      *.tar)       tar xf $1    ;;
      *.tbz2)      tar xjf $1   ;;
      *.tgz)       tar xzf $1   ;;
      *.zip)       unzip $1     ;;
      *.Z)         uncompress $1;;
      *.7z)        7z x $1      ;;
      *)           echo "'$1' cannot be extracted via ex()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}
#+end_src
** un-section
*** untar
#+begin_src shell
function untar() {
  if [ -f "$1" ]; then
    tar -xvf "$1" && c
  else
    echo "$1 is not a valid tar archive"
  fi
}
#+end_src
*** unvim
#+begin_src shell
function unvim() {
  # rm -rf ~/.config/nvim
  rm -rf ~/.local/share/nvim
}
#+end_src
*** ungit
#+begin_src shell
function ungit() {
  rmdir .git
  echo "WHAT ARE YOU DOING ?" && sleep 1 && rm .gitignore && c
}
#+end_src
*** ungo
#+begin_src shell
function ungo() {
  rm go.mod
  echo "WHAT ARE YOU DOING ?" && sleep 1 && c
}
#+end_src
*** uncargo
Check if a Cargo.toml file exists in the current directory
#+begin_src shell
function uncargo() {
  if [ ! -f "Cargo.toml" ]; then
    echo "No Cargo.toml file found in the current directory."
    return 1
  fi

  # Remove the Cargo.toml and Cargo.lock files
  rm -f Cargo.toml Cargo.lock

  # Search for a src directory and rename it to unrusted-src
  if [ -d "src" ]; then
    mv src unrusted-src
    echo "src directory renamed to unrusted-src."
  else
    echo "No src directory found."
  fi
  c
}
#+end_src
** lifehacks
*** gen
gen 10 xos.c
#+begin_src shell

function gen () {
  local count=1
  local prefix=${2%.*}

  while [[ $count -le $1 ]]; do
    touch "${prefix}${count}.${2#*.}"
    count=$(( count + 1 ))
  done
}

#+end_src
** explain
"explain" any shell function, alias, variable..
#+begin_src shell
function explain() {
  local name=$1
  local def=$(declare -f $name 2>/dev/null)

  case "$name" in
    ltree)
      local desc="Recursive directory listing with optional custom prompt"
      ;;
    lfcd)
      local desc="cd to the parent directory containing a file or directory matching the given pattern"
      ;;
    c)
      local desc="Compile and run a C program with a single command"
      ;;
    *)
      local desc=""
      ;;
  esac

  if [[ -n "$desc" ]]; then
    echo -e "\033[0;33m$desc:\033[0m"
  fi

  if [[ -n "$def" ]]; then
    # echo -e "\033[0;33mDefined in current shell session:\033[0m"
    echo $def | pygmentize -f terminal256 -O style=native
  else
    local info=$(type -a $name 2>/dev/null)

    if [[ -n "$info" ]]; then
      echo -e "\033[0;33m$info:\033[0m"
      echo $(echo $info | cut -d ' ' -f 3-) | head -n 1 | pygmentize -f terminal256 -O style=native
    else
      echo "$name not found"
      return 1
    fi
  fi
}

#+end_src
** formatting
*** color
SYNTAX : <command> | color <color>
#+begin_src shell

color() {
  # Check if color is set in terminal, otherwise get it from xresources
  if [[ -n "$TERM" ]]; then
    case "$1" in
      black)   color="\033[0;30m" ;;
      red)     color="\033[0;31m" ;;
      green)   color="\033[0;32m" ;;
      yellow)  color="\033[0;33m" ;;
      blue)    color="\033[0;34m" ;;
      purple)  color="\033[0;35m" ;;
      cyan)    color="\033[0;36m" ;;
      white)   color="\033[0;37m" ;;
      *)       color="\033[0m"     ;;
    esac
  elif [[ -n "$XTERM_VERSION" ]]; then
    case "$1" in
      black)   color="\033[0;30m" ;;
      red)     color="\033[0;31m" ;;
      green)   color="\033[0;32m" ;;
      yellow)  color="\033[0;33m" ;;
      blue)    color="\033[0;34m" ;;
      purple)  color="\033[0;35m" ;;
      cyan)    color="\033[0;36m" ;;
      white)   color="\033[0;37m" ;;
      *)       color="\033[0m"     ;;
    esac
  else
    color="\033[0m"
  fi

  # Read input from pipe and colorize it
  while read -r line; do
    echo -e "${color}${line}\033[0m"
  done
}
#+end_src
** backup
#+begin_src shell
backup () {
    if [ -z "$1" ]; then
        echo -e "\033[0;31mError: Please specify a file or directory to backup\033[0m"
        return 1
    fi

    local backup_dir="$(pwd)/${1}-backup-$(date +%Y-%m-%d-%H-%M-%S)"
    cp -r "$1" "$backup_dir" && \
    echo -e "\033[0;32mâœ” Success: Created backup in $backup_dir\033[0m" && \
    bat "$backup_dir"
}
#+end_src
** ls
*** ccx
clickable ls
#+begin_src shell
#HACK cd into the clicked dir
function ccx() {
    local dir="$1"
    local full_dir
    if [ ! -d "$dir" ]; then
        mkdir -p "$dir"
    fi
    full_dir=$(realpath "$dir")
    clear && cd "$full_dir" && ls --color=always -1 | awk -v pwd="$full_dir" '{ printf "\033]8;;file://localhost" pwd "/" $0 "\007" $0 "\033]8;;\007\n" }'
}
#+end_src
** compile
#+begin_src shell

function compile() {
    if [[ -z "$1" ]]; then
        echo "Usage: compile <file>"
        return 1
    fi

    case "${1##*.}" in
        c)
            gcc -Wall -Wextra -Wpedantic -std=c99 -O2 -o "${1%.*}" "$1" && "./${1%.*}"
            ;;
        cpp)
            g++ -Wall -Wextra -Wpedantic -std=c++17 -O2 -o "${1%.*}" "$1" && "./${1%.*}"
            ;;
        py)
            python "$1"
            ;;
        lua)
            lua "$1"
            ;;
        hs)
            ghc -O2 -o "${1%.*}" "$1" && "./${1%.*}"
            ;;
        cs)
            mcs "$1" && mono "${1%.*}.exe"
            ;;
        lisp)
            sbcl --script "$1"
            ;;
        ,*)
            echo "Error: Unsupported file type"
            return 1
            ;;
    esac
}


#+end_src
* terminal-image-manipulation
** img-resize
#+begin_src shell
function img-resize() {
    if [ $# -ne 3 ]; then
        echo "Usage: xresize <input-file> <width> <height>"
        return 1
    fi

    local input_file="$1"
    local width="$2"
    local height="$3"
    local file_extension="${input_file##*.}"
    local output_file="${input_file%.*}${width}x${height}.${file_extension}"
    local lowercase_file_extension="$(echo "$file_extension" | tr '[:upper:]' '[:lower:]')"

    if [[ "${lowercase_file_extension}" =~ ^(jpg|jpeg|png)$ ]]; then
        convert "${input_file}" -resize "${width}x${height}" "${output_file}"
        echo "Resized ${input_file} to ${output_file}"
    else
        echo "Invalid file extension. Supported formats: jpg, jpeg, png"
        return 1
    fi
}
#+end_src
*** render
#+begin_src shell
render () {
	if [[ $# -eq 0 ]]
	then
		echo "Usage: render <image_file1> [<image_file2> ...]"
		return 1
	fi
	if ! command -v kitty > /dev/null
	then
		echo "Error: 'kitty' terminal emulator is not installed or not in PATH."
		return 1
	fi
	if ! command -v icat > /dev/null
	then
		echo "Error: 'icat' feature is not enabled in 'kitty'."
		return 1
	fi

	for image_file in "$@"
	do
		if [[ ! -f "$image_file" ]]
		then
			echo "Error: File '$image_file' not found."
			return 1
		fi
		kitty +kitten icat "$image_file"
	done
}

#+end_src
* admin
** copy
#+begin_src shell
 copied=()
 copy() { # copy dir/file to paste in other dir
  if [[ $# -eq 0 ]]; then
    copy $PWD
    return 1
  fi
  if [[ "${1:-}" == "-l" ]]; then
    if [[ ${#copied[@]} -eq 0 ]]; then
      echo "No items have been copied yet."
    else
      echo "Previously copied items:"
      printf '%s\n' "${copied[@]}"
    fi
  elif [[ "${1:-}" == "-c" ]]; then
    copied=()
    echo "Cleared the list of copied items."
  else
    while [[ $# -gt 0 ]]; do
      local source=$(realpath "$1") # Convert to absolute path

      if [[ ! -e $source ]]; then
        echo "The specified path does not exist: $source"
      else
        copied+=("$source")
        echo "Copied: $source"
        echo -n "$source" | xclip -selection clipboard # Copy the path to clipboard
      fi
      shift
    done
  fi
 }
#+end_src
*** paste
#+begin_src shell
 paste() { # paste copied dirs/files in other dir
  local destination=$PWD
  local move=false
  if ! command -v fzf &> /dev/null; then
    echo "fzf is required but not installed. Aborting."
    exit 1
  fi
  while getopts ":mh" opt; do
    case $opt in
      m)
        move=true
        ;;
      h)
        echo "Usage: paste [-m] [-h] (move)"
        exit 0
        ;;
      \?)
        echo "Invalid option: -$OPTARG"
        exit 1
        ;;
    esac
  done
  if [[ ${#copied[@]} -eq 0 ]]; then
    echo "No items have been copied yet."
    exit 1
  fi
  selected_items=$(printf "%s\n" "${copied[@]}" | splittedfzf --multi)
  if [[ -z "$selected_items" ]]; then
    echo "No items selected. Aborting."
    exit 1
  fi
  if [[ $# -gt 0 ]]; then
    destination="$1"
    shift
  fi
  if [[ ! -d $destination ]]; then
    echo "The destination path is not a valid directory: $destination"
    exit 1
  fi
  while read -r item; do
    if $move; then
      if [[ -e $item ]]; then
        mv -f "$item" "$destination" 2>/dev/null
        echo "Moved: $item to $destination"
      fi
    else
      if [[ -e $item ]]; then
        cp -rf "$item" "$destination" 2>/dev/null
        echo "Copied: $item to $destination"
      fi
    fi
  done <<< "$selected_items"
 }
alias splittedfzf='fzf-tmux -x --height ${FZF_TMUX_HEIGHT:-40%} -m --reverse --ansi'

#+end_src
** mdir
#+begin_src shell
function mdir () {
  command mkdir -p "$@" && c "${@: -1}" && c
}
#+end_src
** rmdir
#+begin_src shell
rmdir() {
  if [ -d "$1" ]; then
    rm -rf "$1"
  else
    echo "Error: '$1' is not a directory"
  fi
}
#+end_src
** mvall
#+begin_src shell
function mvall() {
  # Get the destination path from the first argument
  dest_path="$1"

  # Create the destination directory if it doesn't exist
  mkdir -p "$dest_path"

  # Move all files and directories in the current directory to the destination directory, excluding .git
  rsync -av --exclude=".git" --remove-source-files . "$dest_path"
}
#+end_src
** cpall
#+begin_src shell
function cpall() {
  # Get the destination path from the first argument
  dest_path="$1"

  # Create the destination directory if it doesn't exist
  mkdir -p "$dest_path"

  # Copy all files and directories in the current directory to the destination directory, excluding .git
  rsync -av --exclude=".git" . "$dest_path"
}
#+end_src
** rmall
#+begin_src shell
function rmall () {
  current_dir=$(pwd)
  case "$1" in
    -f)  # remove all files
      noglob find "$current_dir" -mindepth 1 -maxdepth 1 -type f ! -name ".gitignore" -exec rm -f {} +
      ;;
    -d)  # remove all directories
      noglob find "$current_dir" -mindepth 1 -maxdepth 1 -type d ! -name ".git" -exec rm -rf {} +
      ;;
    *)  # remove all files and directories
      noglob find "$current_dir" -mindepth 1 -maxdepth 1 ! -name ".git" -exec rm -rf {} +
      ;;
  esac
}
#+end_src
* enviroment
** variables
#+begin_src shell
here=$PWD
#+end_src
* SSH
** key
#+begin_src shell
function key() {
  case "$1" in
    list)
      # List all SSH keys with Dracula theme
      echo -e "\033[0;35m=== SSH Keys ===\033[0m"
      for file in ~/.ssh/*.pub; do
        echo -e "\033[0;32m$(basename "$file")\033[0m"
      done
      ;;
    edit)
      # Template for editing SSH keys
      echo -e "\033[0;36m=== Edit SSH Keys ===\033[0m"
      echo "TODO: Add your key edit code here"
      ;;
    ,*)
      # Invalid option
      echo -e "\033[0;31mInvalid option. Usage: key [list|edit]\033[0m"
      ;;
  esac
}

#+end_src
** delete all keys
#+begin_src shell
function ssh-delete-all-keys() {
    echo "Deleting all local SSH keys..."
    rm -rf ~/.ssh/*
    echo "All local SSH keys have been deleted."
}

#+end_src
** generate-ssh-key
#+begin_src shell

function ssh-key-generate-interactive() {
    local email
    local key_name

    echo -e "\033[0;35m======= Generate SSH Key =======\033[0m"

    # Prompt for email
    echo -e "\033[0;36mEnter your email address:\033[0m"
    read email

    # Prompt for key name
    echo -e "\033[0;36mEnter a name for your SSH key:\033[0m"
    read key_name

    if [ -z "$email" ] || [ -z "$key_name" ]; then
        echo -e "\033[0;31mPlease provide an email address and a key name.\033[0m"
        return 1
    fi

    echo -e "\033[0;35m======= Generating SSH Key =======\033[0m"
    ssh-keygen -t rsa -b 4096 -C "$email" -f "$HOME/.ssh/$key_name"

    echo -e "\033[0;35m======= SSH Key Generated =======\033[0m"
    echo -e "\033[0;32mPublic key: $HOME/.ssh/$key_name.pub\033[0m"
    echo -e "\033[0;32mPrivate key: $HOME/.ssh/$key_name\033[0m"

    echo -e "\033[0;35mTo use this SSH key, you can add it to your GitHub account or other remote systems.\033[0m"
}
#+end_src

* ARCHISO-UTILS
** iso-init
#+begin_src shell
function iso-init() {
  # Check if archiso package is installed
  if ! command -v mkarchiso &>/dev/null; then
    # Archiso package not found, prompt to install it
    read -p "The 'archiso' package is required but not installed. Do you want to install it? (y/n): " choice
    if [[ $choice =~ ^[Yy]$ ]]; then
      # Install archiso package using sudo pacman
      sudo pacman -S archiso
    else
      echo "Aborted. 'archiso' package not installed."
      return 1
    fi
  fi

  # Set Dracula colorscheme
  export LSCOLORS="Gxfxcxdxbxegedabagacad"
  export LS_COLORS="$LS_COLORS:ow=1;36:"

  # Copy archiso configs
  sudo cp -r /usr/share/archiso/configs/releng/ "$here"
}
#+end_src
** iso-build
#+begin_src shell

function iso-build {
  local script_dir="$(dirname "$0")"
  local releng_dir="$(realpath "$script_dir/releng")"
  local output_dir="$PWD/output"

  # Check if the releng_dir exists
  if [[ ! -d $releng_dir ]]; then
    echo -e "\033[31mError: $releng_dir is not a directory\033[0m"
    return 1
  fi

  # Create the output directory if it doesn't exist
  mkdir -p "$output_dir"

  # Build the ISO image
  sudo mkarchiso -v -w "$PWD/iso" -o "$output_dir" "$releng_dir"

  # Display a success message in green
  echo -e "\033[32mSuccess! ISO image has been built in $output_dir/\033[0m"
}
#+end_src

* PROMPT
owerwrite the fallback prompt
#+begin_src shell
# eval "$(starship init zsh)"
# eval "$(oh-my-posh init zsh)"
#+end_src
* fzf
** themses
*** PALENIGHT
#+begin_src shell
export FZF_DEFAULT_OPTS=" \
--color=bg+:#292D3E,bg:#292D3E,spinner:#C792EA,hl:#82AAFF \
--color=fg:#EEFFFF,header:#82AAFF,info:#89DDFF,pointer:#C792EA \
--color=marker:#C792EA,fg+:#EEFFFF,prompt:#89DDFF,hl+:#82AAFF"
#+end_src
*** DRACULA
#+begin_src shell
# TODO
# export FZF_DEFAULT_OPTS=" \
# --color=bg+:#282a36,bg:#1e1e2e,spinner:#f8f8f2,hl:#ff79c6 \
# --color=fg:#f8f8f2,header:#ff79c6,info:#8be9fd,pointer:#50fa7b \
# --color=marker:#50fa7b,fg+:#f8f8f2,prompt:#8be9fd,hl+:#ff79c6"
#+end_src
*** CATPPUCCIN
#+begin_src shell
# export FZF_DEFAULT_OPTS=" \
# --color=bg+:#313244,bg:#1e1e2e,spinner:#f5e0dc,hl:#f38ba8 \
# --color=fg:#cdd6f4,header:#f38ba8,info:#cba6f7,pointer:#f5e0dc \
# --color=marker:#f5e0dc,fg+:#cdd6f4,prompt:#cba6f7,hl+:#f38ba8"
#+end_src
* DESKTOP
** xrate
#+begin_src shell
function xrate() {
  if [ "$#" -ne 1 ] || ! [[ "$1" =~ ^[0-9]+$ ]]; then
    echo "Usage: xrate [refresh rate]"
    return 1
  fi

  local refresh_rate=$1
  local connected_display=$(xrandr | grep ' connected' | awk '{print $1}')

  xrandr --output "$connected_display" --mode 1920x1080 --rate "$refresh_rate"
}
#+end_src
* xos-package-manager
 no functionality from pacman will be missed
*** pullpkg
#+begin_src shell
function pullpkg() {
  HELPER=${HELPER:-yay} # Set default AUR helper to yay if HELPER variable not defined
  for pkgname in $*; do
    git clone "https://aur.archlinux.org/$pkgname.git"
    cd "$pkgname"
    "$HELPER" --downloadonly --noredownload --noconfirm
    cd ..
  done
}
#+end_src
*** get
#+begin_src shell
function get() {
    if sudo pacman -S "$@"; then
        echo "Package installed successfully with pacman."
    else
        echo "Pacman could not find the package. Trying with yay..."
        if yay -S "$@"; then
            echo "Package installed successfully with yay."
        else
            echo "yay could not find the package either."
        fi
    fi
}
#+end_src
*** pacanalize
#+begin_src shell
function pacanalize() {
    # Fetch package data
    local all=$(pacman -Q | wc -l)
    local pkg=$(pacman -Qe | wc -l)
    local official_pkg=$(pacman -Qen | wc -l)
    local aur_pkg=$(pacman -Qem | wc -l)
    local dep_pkg=$(pacman -Qd | wc -l)
    local official_dep_pkg=$(pacman -Qdn | wc -l)
    local aur_dep_pkg=$(pacman -Qdm | wc -l)

    # Show spinner
    gum spin --title="Analyzing packages ðŸš€" -- sleep 1

    # Display the data with styling
    gum style --bold "All Packages: $all"
    gum style "  Packages: $pkg"
    gum style "    Official Packages: $official_pkg"
    gum style "    AUR Packages: $aur_pkg"
    gum style "  Dependent Packages: $dep_pkg"
    gum style "    Official Dependent Packages: $official_dep_pkg"
    gum style "    AUR Dependent Packages: $aur_dep_pkg"
}
#+end_src
*** pacinfo
#+begin_src shell
pacinfo() {
    if [ $# -eq 0 ]; then
        echo "Error: Please provide at least one package name." | color red
        return 1
    fi

    for pkg in "$@"; do
        local info=$(pacman -Qi $pkg)

        if [ -z "$info" ]; then
            echo "Error: Package '$pkg' not found." | color red
            continue
        fi

        echo -e "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" | color blue
        echo " Package Information for $pkg " | color blue
        echo -e "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" | color blue

        echo "$info" | while read -r line; do
            case "$line" in
                Name*)
                    echo "$line" | color green;;
                Version*)
                    echo "$line" | color purple;;
                Description*)
                    echo "$line" | color yellow;;
                Architecture*)
                    echo "$line" | color cyan;;
                URL*)
                    echo "$line" | color blue;;
                Licenses*)
                    echo "$line" | color green;;
                Groups*)
                    echo "$line" | color yellow;;
                Provides*)
                    echo "$line" | color cyan;;
                Depends*)
                    echo "$line" | color purple;;
                Optional*)
                    echo "$line" | color red;;
                Conflicts*)
                    echo "$line" | color red;;
                Installed*)
                    echo "$line" | color cyan;;
                *)
                    echo "$line" | color white;;
            esac
        done
    done
}
#+end_src
**** _pacinfo
#+begin_src shell
_pacinfo() {
    local state line
    typeset -A opt_args

    _arguments -C \
        '1: :->packages' \
        '*:: :->other'

    case $state in
        packages)
            local -a completions
            completions=($(pacman -Qq))
            _describe 'packages' completions
            ;;
        other)
            ;;
    esac
}

# Register the _pacinfo function for autocompletion with pacinfo
compdef _pacinfo pacinfo
#+end_src

* my-useless-creations
** freedom
it doesnt actually work
#+begin_src shell
function freedom() {
  for package in $(pacman -Qq); do
    license=$(pacman -Qi $package | awk '/License/ { print $3 }')
    if [[ $license =~ "custom:..(noncommercial|nolicense|permissive)" || $license =~ "AGPL" || $license =~ "Apache" || $license =~ "Artistic" || $license =~ "BSD" || $license =~ "CC-BY" || $license =~ "CC-BY-NC" || $license =~ "CC-BY-ND" || $license =~ "CC-BY-SA" || $license =~ "CC-BY-NC-SA" || $license =~ "CDDL" || $license =~ "EPL" || $license =~ "GPL" || $license =~ "LGPL" || $license =~ "MIT" || $license =~ "MPL" || $license =~ "OpenSSL" || $license =~ "Python" || $license =~ "W3C" || $license =~ "Zlib" ]]; then
      echo -e "${package}\t\e[32mFREE\e[0m"
    else
      echo -e "${package}\t\e[31mPROPRIETARY\e[0m"
    fi
  done
}
#+end_src
* XORG-TOOL-BOX
** start
#+begin_src shell
function start() {
  if [[ -z $1 ]]; then
    startx
  else
    set-wm "$1" && startx
  fi
}
#+end_src
*** SET-WM
#+begin_src shell
function set-wm() {
    local program_name="$1"
    local xinitrc_file="/etc/X11/xinit/xinitrc"
    if sudo sed -i "\$s|^exec.*|exec $program_name|" "$xinitrc_file"; then
        echo "Last 'exec' line updated in $xinitrc_file"
    else
        echo "No 'exec' line found in $xinitrc_file"
    fi
}
#+end_src
** autologin
Toggle systemd autologin for current user
#+begin_src shell
function autologin() {
        if [[ "$1" == "info" ]]; then
            local tty_number="1"
            local service_file="/etc/systemd/system/getty@tty${tty_number}.service.d/autologin.conf"
            if [[ -f "$service_file" ]]; then
                echo "Auto-login enabled"
            else
                echo "Auto-login disabled"
            fi
        else
            local tty_number="1"
            local service_dir="/etc/systemd/system/getty@tty${tty_number}.service.d"
            local service_file="$service_dir/autologin.conf"
            local current_user=$(whoami)
            if [[ -f "$service_file" ]]; then
                sudo rm "$service_file" && \
                sudo systemctl daemon-reload && \
                echo "Auto-login disabled for tty${tty_number}"
            else
                if [[ ! -d "$service_dir" ]]; then
                    sudo mkdir -p "$service_dir"
                fi
                echo "[Service]
    ExecStart=
    ExecStart=-/sbin/agetty --autologin $current_user --noclear %I $TERM" | sudo tee "$service_file" > /dev/null
                sudo systemctl daemon-reload && \
                echo "Auto-login enabled for tty${tty_number} with user $current_user"
            fi
        fi
    }
#+end_src
** xgeometry
interactively click the desired window
#+begin_src shell
xgeometry() {
  xwininfo_output=$(xwininfo -frame)
  x=$(echo "$xwininfo_output" | awk '/Absolute upper-left X:/ { print $4 }')
  y=$(echo "$xwininfo_output" | awk '/Absolute upper-left Y:/ { print $4 }')
  width=$(echo "$xwininfo_output" | awk '/Width:/ { print $2 }')
  height=$(echo "$xwininfo_output" | awk '/Height:/ { print $2 }')

  echo "X: $x"
  echo "Y: $y"
  echo "Width: $width"
  echo "Height: $height"
}
#+end_src
** xgeometry_focused
output x, y, width, height about the currently focused window, WORKS WITH ANY WM
#+begin_src shell
function xgeometry-focus() {
	focused_window_id=$(xdotool getwindowfocus)
	xwininfo_output=$(xwininfo -id "$focused_window_id")
	x=$(echo "$xwininfo_output" | awk '/Absolute upper-left X:/ { print $4 }')
	y=$(echo "$xwininfo_output" | awk '/Absolute upper-left Y:/ { print $4 }')
	width=$(echo "$xwininfo_output" | awk '/Width:/ { print $2 }')
	height=$(echo "$xwininfo_output" | awk '/Height:/ { print $2 }')
	echo "X: $x"
	echo "Y: $y"
	echo "Width: $width"
	echo "Height: $height"
}
#+end_src
* MOTIONS
** c
c will replace cd in most zsh functions
#+begin_src shell
function c() {
    local dir="$1"
    if [ ! -d "$dir" ]; then
        mkdir -p "$dir"
    fi
    clear && cd "$dir" && exa -la # &&  ls -l -a | wc -l
}
#+end_src
** xos
#+begin_src shell
function xos() {
    c ~/xos/$1/$2/$3
}
#+end_src
** dotfiles
#+begin_src shell
function dotfiles() {
  c ~/Desktop/pulls/dotfiles/$1/$2/$3
}
#+end_src
*** _dotfiles
This function is defined to provide autocompletion suggestions.
#+begin_src shell
# Define color variables
typeset -A config
config=(
  show_hidden  true
)

# Autocompletion function
function _dotfiles() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    _arguments -C \
        '1: :->files' \
        '*:: :->other'

    case $state in
        files)
            local IFS=$'\n'
            local -a completions
            if [[ ${config[show_hidden]} == true ]]; then
              completions=($(ls -A ~/Desktop/pulls/dotfiles))
            else
              completions=($(ls ~/Desktop/pulls/dotfiles))
            fi
            _describe 'files' completions
            ;;
        other)
            ;;
    esac
}

# Register the function for autocompletion
compdef _dotfiles dotfiles
#+end_src
** conf
#+begin_src shell
function conf() {
  local x=~/.config
  for arg in $@; do
    x+="/$arg"
  done
  if [ -d "$x" ]; then
    cd "$x"
  else
    echo "Directory not found: $x"
  fi
}
#+end_src
*** _conf
#+begin_src shell
_conf() {
  local curcontext="$curcontext" state line
  _path_files -W "$HOME/.config/" && return
  return 1
}
compdef _conf conf
#+end_src
** lfcd
#+begin_src shell
lfcd () {
    tmp="$(mktemp)"
    lf -last-dir-path="$tmp" "$@"
    if [ -f "$tmp" ]; then
        dir="$(cat "$tmp")"
        rm -f "$tmp"
        [ -d "$dir" ] && [ "$dir" != "$(pwd)" ] && c "$dir"
    fi
}
#+end_src
** test
#+begin_src shell
function test() {
    c ~/Desktop/test/$1/$2/$3
}
#+end_src
** script
#+begin_src shell
function script() {
    c ~/xos/script/$1/$2/$3
}
#+end_src
* GIT
** gclone
git clone, but you can display a custom image
#+begin_src shell
function gclone() {
  clear
  if [ $# -lt 1 ]; then
    echo "Usage: gclone <repository> [directory]"
    return 1
  fi

  # Set the repository URL and directory name from the input arguments
  local repo="$1"
  local dir="$2"

  # Display the cloning image inside the terminal using kitty icat
  kitty +kitten icat ~/Desktop/xos/xassets/git.png

  # Use the name of the repository as the directory name if none is provided
  if [ -z "$dir" ]; then
    dir=$(basename "$repo" .git)
  fi

  # Clone the repository into the specified directory and change into the cloned directory
  git clone "$repo" "$dir" && c "$dir"
}
#+end_src
** gitgo
#+begin_src shell
gitgo() {
    # Check if inside a git repository
    if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        # Extract the remote repository URL
        remote_url=$(git config --get remote.origin.url)
        # Convert git URL to HTTPS URL if needed
        if [[ "$remote_url" == git@github.com:* ]]; then
            remote_url=${remote_url/git@github.com:/https://github.com/}
            remote_url=${remote_url%.git}
        fi
        # Open the remote URL in the default web browser
        xdg-open "$remote_url"
    else
        # If not inside a git repository, open the GitHub homepage
        xdg-open "https://github.com"
    fi
}

alias ggo='gitgo'
#+end_src
** ginit
inizialize a and push an entire directory to github
#+begin_src shell
ginit() {
  # Check if `gh` and `git` commands are installed
  command -v gh >/dev/null 2>&1 || { echo >&2 "The 'gh' command is required. Please install it before running this function."; return 1; }
  command -v git >/dev/null 2>&1 || { echo >&2 "The 'git' command is required. Please install it before running this function."; return 1; }

  # Check if repository name is provided
  if [ -z "$1" ]; then
    echo "Please provide a repository name as an argument."
    return 1
  fi

  # Options
  local commit_message="first commit"
  local branch_name="main"

  # Check if directory size exceeds 2 GB
  if [ "$(du -sb . | cut -f1)" -gt $((2*1024*1024*1024)) ]; then
    echo "The directory size exceeds 2 GB. Aborting."
    return 1
  fi

  # Create the repository on GitHub
  echo "Creating repository $1 on GitHub..."
  gh repo create "$1" --public

  # Initialize the local Git repository
  echo "Initializing local Git repository..."
  git init

  # Copy the README.md file to the current directory
  # echo "Copying README.md file..."
  # cp ~/Desktop/test/smart-git/BLANK_README.md README.md
  # cp -R ~/Desktop/test/smart-git/images .


  # Add all files in current directory to the staging area
  echo "Adding all files to the staging area..."
  git add .

  # Commit the changes
  echo "Committing changes..."
  git commit -m "$commit_message"

  # Rename the default branch to main
  echo "Renaming default branch to $branch_name..."
  git branch -M "$branch_name"

  # Set the remote origin to the GitHub repository
  echo "Setting remote origin to GitHub repository..."
  git remote add origin "https://github.com/laluxx/$1.git"

  # Push the changes to the remote repository
  echo "Pushing changes to remote repository..."
  git push -u origin "$branch_name"

  echo "Done!"
}
#+end_src
** clone
clone directly from you GH account
#+begin_src shell
function clone() {
    local github_account="laluxx"
    git clone "https://github.com/${github_account}/$1.git"
}
#+end_src
** origin
#+begin_src shell
function origin() {
  gh repo set-default
}
#+end_src
** rmrepo
#+begin_src shell
#TODO
function rmrepo() {
  repo_name="$1"
  gh repo delete "$repo_name" --yes
}
#+end_src
** pulls
#+begin_src shell
function pulls(){
  c ~/Desktop/pulls/$1/$2/$3
}
#+end_src
** dd-iso
#+begin_src shell
#TODO
function dd_iso() {
  # Define a function to show the lsblk output with custom formatting and color
  function show_lsblk() {
    lsblk --fs --output NAME,FSTYPE,LABEL,SIZE,MOUNTPOINT | awk '{ printf "\e[1m%-20s %-10s %-10s %-10s %-20s\e[0m\n", $1, $2, $3, $4, $5 }'
  }

  # Define a function to show the ISO file description
  function show_iso_description() {
    if [[ -n $iso ]]; then
      echo -e "\e[1mISO file information:\e[0m"
      isoinfo -d -i "$iso" | sed 's/^/  /'
    fi
  }

  # Use fzf to select an ISO file from the ~/Downloads/iso directory
  iso=$(find ~/Downloads/iso -maxdepth 1 -type f -name "*.iso" | fzf --prompt "Select an ISO file: " \
    --preview-window=right:60% \
    --preview="echo -e \"\e[1mSelected ISO file:\e[0m\n  {}\"; show_iso_description")

  # Exit if no ISO file is selected
  if [[ -z $iso ]]; then
    echo "No ISO file selected."
    return
  fi

  # Use lsblk with custom formatting to select a disk to write to
  disk=$(lsblk --noheadings --list --output NAME,SIZE | fzf --prompt "Select a disk to write to: " \
    --preview-window=right:60% \
    --preview="echo -e \"\e[1mSelected disk:\e[0m\n  {}\"; show_lsblk | grep -E \"(^| ){}($| )\"")

  # Exit if no disk is selected
  if [[ -z $disk ]]; then
    echo "No disk selected."
    return
  fi

  # Print lsblk output with custom formatting and color
  show_lsblk

  # Prompt the user for confirmation before proceeding
  read -rp "Are you sure you want to write $iso to $disk? (y/N) " confirm
  if [[ ! $confirm =~ ^[yY]$ ]]; then
    echo "Aborting."
    return
  fi

  # Use dd to write the selected ISO file to the selected disk
  echo "Writing $iso to $disk..."
  sudo dd bs=4M if="$iso" of="/dev/$disk" status=progress conv=fsync oflag=direct
  echo "Done!"
}
#+end_src
* XOS
** XOS-UPDATE
#+begin_src shell
function xos-update() {
    local xos_path="$HOME/xos"
    local dotfiles_repo="https://github.com/laluxx/dotfiles.git"
    local destination_dir="$HOME/Desktop/pulls/dotfiles"

    # Silently change to the xos directory
    cd "$xos_path" || return 1

    # Remove the existing dotfiles directory if it exists
    [[ -d dotfiles ]] && rm -rf dotfiles

    # Clone the dotfiles repository
    git clone --quiet "$dotfiles_repo" dotfiles || return 1

    # Rsync the dotfiles directory to your local repository
    rsync -a "$xos_path/dotfiles/" "$destination_dir/"

    echo "XOS updated"

    # Call the update-dotfiles function to sync to home directory
    update-dotfiles
}
#+end_src
*** UPDATE DOTFILES
#+begin_src shell
function update-dotfiles() {
    dotfiles_path="$HOME/Desktop/pulls/dotfiles"

    rsync -a "$dotfiles_path"/. "$HOME"/
    echo "Updated dotfiles"
}
#+end_src
** xos-doctor
#+begin_src shell
function xos-doctor() {
    sudo lynis audit system
}
#+end_src
* GUM
** theme
#+begin_src shell
# export GUM_INPUT_CURSOR_FOREGROUND=""
export GUM_INPUT_PROMPT_FOREGROUND="#A3F7FF"
export GUM_INPUT_PLACEHOLDER="What's up?"
export GUM_INPUT_PROMPT="âžœ "
export GUM_INPUT_WIDTH=80
#+end_src
** gum-commit
#+begin_src sh
function gum-commit(){
TYPE=$(gum choose "fix" "feat" "docs" "style" "refactor" "test" "chore" "revert")
SCOPE=$(gum input --placeholder "scope")

# Since the scope is optional, wrap it in parentheses if it has a value.
test -n "$SCOPE" && SCOPE="($SCOPE)"

# Pre-populate the input with the type(scope): so that the user may change it
SUMMARY=$(gum input --value "$TYPE$SCOPE: " --placeholder "Summary of this change")
DESCRIPTION=$(gum write --placeholder "Details of this change (CTRL+D to finish)")

# Commit these changes
gum confirm "Commit changes?" && git commit -m "$SUMMARY" -m "$DESCRIPTION"
}
#+end_src
* INSTANT-MENU
#+begin_src shell

# Define Color Schemes
typeset -A color_schemes
color_schemes=(
  'dracula' '#282A36 #F8F8F2 #FF79C6 #F8F8F2'
  'doom-one' '#282c34 #bbc2cf #98be65 #282c34'
  # Format 'name' 'background foreground selection selected_text'
)

# ZSH function for Instant Menu
instant_menu() {
  # Select the color scheme
  local -a colors
  IFS=' ' read -r -A colors <<< "${color_schemes[$1]}"

  # Generate menu
  programs=$(ls /usr/bin | sort -u)
  chosen=$(echo -e "$programs" | instantmenu -i -l 20 -h 30 -w 600 \
      -x $(( ($(xdotool getdisplaygeometry | cut -d ' ' -f1) - 600) / 2 )) \
      -y $(( ($(xdotool getdisplaygeometry | cut -d ' ' -f2) - 600) / 2 )) \
      -nb ${colors[1]} -nf ${colors[2]} -sb ${colors[3]} -sf ${colors[4]})

  # Run chosen program
  [[ -n $chosen ]] && $chosen &
}

# Usage: instant_menu 'dracula'
#        instant_menu 'doom-one'




#+end_src

* WAL
** wal-set
Find all .png, .jpg, .jpeg,  files in the directory, pipe into fzf
#+begin_src shell
wal-set () {
    local dir=~/xos/wallpapers/static
    local wallpaper=$(find "$dir" \( -name "*.png" -o -name "*.jpg" -o -name "*.jpeg" -o -name "*.webp" \) -type f | fzf --height 40% -m --reverse --ansi --cycle)
    if [[ -n "$wallpaper" ]]
    then
        wal -i "${wallpaper}" -q
        echo "Wallpaper set to ${wallpaper}"

        # Open a new horizontally split window and display the selected image using kitty icat
        kitty @ new-window --layout horizontal kitty +kitten icat "${wallpaper}"

    else
        echo "No wallpaper selected."
    fi
}

#+end_src

* cheat sheets
** V2
#+begin_src shell
ch() { # Comunity driven cheatsheet for linux commands
        for arg in "$@"; do
        if [[ ! "$@" = /* ]]; then
            arg="/$@"
        else
            arg="$@"
        fi
        curl -sS cheat.sh$arg | sed 's/\x1b[[0-9;]*m//g' | bat --style=plain --color=always --theme ansi --file-name $@
        done
    }
#+end_src
* Qr
generate qrcodes of text/links
** qr-gen
#+begin_src shell
qr-gen() {       if [ -z "$1" ]; then
        echo "Usage: qrgen <text_or_url>"
        return 1
      fi
      local input="$1"
      local api_url="https://qrenco.de/$input"
      curl -s $api_url || echo "Failed to generate QR Code."
    }
#+end_src
** qr-scan
#+begin_src shell
qr-scan() {
    # Create a temporary file to store the screenshot
    tmpfile=$(mktemp /tmp/qr-scan.XXXXXX.png)

    # Take a screenshot of a selected region and save it to the temporary file
    maim -s "$tmpfile"

    # Scan the QR code in the screenshot
    url=$(zbarimg --raw --quiet "$tmpfile")

    # Remove the temporary file
    rm "$tmpfile"

    # Open the URL in the default web browser
    if [ -n "$url" ]; then
        xdg-open "$url"
    else
        echo "No QR code found"
    fi
}
#+end_src
* OSU
** osu-cpkeys
#+begin_src shell

osu-cpkeys () {
	if [ "$#" -ne 1 ]
	then
		echo "Usage: osu-cpkeys <theme_name>"
		return 1
	fi

	theme_name=$1
	destination_directory="$HOME/xos/keyboard-sounds/switches/$theme_name"
	mkdir -p "$destination_directory"

	file_types=("ogg" "wav")

	for file_type in "${file_types[@]}"
	do
		cp -iv key-delete.${file_type} key-press-1.${file_type} key-press-2.${file_type} key-press-3.${file_type} key-press-4.${file_type} key-press.${file_type} "$destination_directory"
	done
}
#+end_src
* Palettes
** pal-gen
#+begin_src shell
pal-gen() {
  # Get the list of palettes
  local palettes="$(lutgen -p 2>&1)"

  # Allow the user to select palettes using fzf (multiple selections allowed).
  local selected_palettes=$(echo "$palettes" | tr ',' '\n' | fzf --multi)

  # Check if the user made a selection
  if [ -z "$selected_palettes" ]; then
    echo "No palette selected"
    return
  fi

  # Generate a LUT image for each selected palette
  # Here we use a while loop to read through newline-separated values
  while read -r palette; do
    if [ -n "$palette" ]; then
      local trimmed_palette=$(echo $palette | xargs) # Remove leading/trailing whitespaces
      echo "Generating LUT for $trimmed_palette"
      lutgen -p $trimmed_palette -o "${trimmed_palette}_lut.png"
    fi
  done <<< "$selected_palettes"
}
#+end_src
** pal-apply
#+begin_src shell
# pal-apply() {
#     local palette selected_images

#     # Predefined palettes list (trimmed down for simplicity; you can use the entire list)
#     local palettes=("catppuccin-frappe" "catppuccin-latte" "catppuccin-macchiato" "catppuccin-mocha" "catppuccin-oled" "adventuretime")

#     # Select a palette from the predefined list
#     palette=$(echo "${palettes[@]}" | tr ' ' '\n' | fzf --prompt='Choose a palette: ')

#     if [ -z "$palette" ]; then
#         echo "No palette selected. Exiting."
#         return 1
#     fi

#     # Select one or more images from the current directory
#     selected_images=$(find . -maxdepth 1 -type f \( -iname \*.jpg -o -iname \*.png -o -iname \*.jpeg \) | fzf --multi --prompt='Choose images to modify: ')

#     if [ -z "$selected_images" ]; then
#         echo "No images selected. Exiting."
#         return 1
#     fi

#     # Loop through the selected images
#     for image in ${(f)selected_images}; do
#         local output_image="modified_${palette}_$(basename "$image")"

#         # Render the original image
#         echo "Rendering original image: $image"
#         render "$image"

#         # Apply the selected palette using lutgen
#         lutgen -p "$palette" apply "$image" -o "$output_image"
#         echo "Modified image saved as $output_image"

#         # Render the modified image
#         echo "Rendering modified image: $output_image"
#         render "$output_image"
#     done
# }
#+end_src
*** wal-opt
#+begin_src shell
pal-apply() {
    local palette selected_images apply_wallpaper=false

    # Predefined palettes list (trimmed down for simplicity; you can use the entire list)
    local palettes=("catppuccin-frappe" "catppuccin-latte" "catppuccin-macchiato" "catppuccin-mocha" "catppuccin-oled" "adventuretime")

    # Parse command-line options
    while getopts "w" opt; do
        case $opt in
            w)
                apply_wallpaper=true
                ;;
            \?)
                echo "Invalid option: -$OPTARG"
                echo "Usage: pal-apply [-w]"
                return 1
                ;;
        esac
    done

    # Remove the parsed options from the argument list
    shift $((OPTIND - 1))

    # Select a palette from the predefined list
    palette=$(echo "${palettes[@]}" | tr ' ' '\n' | fzf --prompt='Choose a palette: ')

    if [ -z "$palette" ]; then
        echo "No palette selected. Exiting."
        return 1
    fi

    # Select one or more images from the current directory
    selected_images=$(find . -maxdepth 1 -type f \( -iname \*.jpg -o -iname \*.png -o -iname \*.jpeg \) | fzf --multi --prompt='Choose images to modify: ')

    if [ -z "$selected_images" ]; then
        echo "No images selected. Exiting."
        return 1
    fi

    # Loop through the selected images
    for image in ${(f)selected_images}; do
        local output_image="modified_${palette}_$(basename "$image")"

        # Render the original image
        echo "Rendering original image: $image"
        render "$image"

        # Apply the selected palette using lutgen
        lutgen -p "$palette" apply "$image" -o "$output_image"
        echo "Modified image saved as $output_image"

        # Render the modified image
        echo "Rendering modified image: $output_image"
        render "$output_image"
    done

    if [ "$apply_wallpaper" = true ]; then
        # Set the modified image as wallpaper using wal
        echo "Setting modified image as wallpaper"
        wal -i "$output_image"
    fi
}
#+end_src
